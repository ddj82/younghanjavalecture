<변수 선언>

//선언만
자료명 변수명;

//선언과 동시에 초기화
자료명 변수명 = 값(리터럴 = Literal);

//자료형이 같은 변수를 동시에 선언 후 초기화
자료명 변수명1, 변수명2, 변수명3;
변수명1 = 값(리터럴);
변수명2 = 값;
...

//자료형이 같은 변수를 동시에 선언 및 초기화
자료명 변수명1 = 값(리터럴), 변수명2 = 값, ...;





<조건문 - if문>

if () {
	실행문들;
	...;

} else if() {
	실행문들;
	...;

} else {
	실행문들;
	...;

}





<조건문 - switch문>

switch (케이스값- byte, short, int, char, String) {
case 1: {
	실행문; 
	break;
}
case 2: {
	실행문; 
	break;
}
case 3: {
	실행문; 
	break;
}
default: {
	실행문;
}





<반복문 - for문>

for (초기식; 조건식; 증감식) {
	실행문들;
	...;
}





<반복문 - for무한루프문>

for ( ; ; ) {
	실행문들;
	...;
}





<반복문 - while문>

기준식;
while (조건식) {
	실행문들;
	...
	제어식이나 제어어(break);
}





<반복문 - while무한루프문>

while (true) {
	실행문들;
	...
	제어식이나 제어어(break);
}





<반복문 - do~while문>

기준식;
do {
	실행문들;
	...
	제어식이나 제어어(break);
} while (조건식);





<반복문 - do~while무한루프문>

기준식;
do {
	실행문들;
	...
	제어식이나 제어어(break);
} while (true);





<상수 선언>

final 자료형 상수명 = 값(리터럴);
**반드시 대문자로 상수명 기술, 반드시 선언과 동시에 초기화





<배열>

//선언
1. 자료형[] 참조변수명; (기본)
2. 자료형 참조변수명[];

//공간생성, 초기화

변수명 = new 자료형[] {값1, 값2, ...};
ㅡㅡㅡㅡㅡ


//선언 및 공간생성(메모리 할당)

자료형[] 변수명 = new 자료형 [방개수];

//초기화 
변수명[인덱스번호(방번호)] = 값1;
변수명[인덱스번호(방번호)] = 값2;
...
ㅡㅡㅡㅡㅡ

//단축형식 (선언 및 공간생성, 초기화)

자료형[] 변수명 = {값1, 값2, ...};
**new가 포함되어 있으며, 처음 설정한 값(요소)의 개수만큼 방 크기가 고정된다.





<for확장형>

배열변수
for (자료형 변수명 : 배열객체명) {
	실행문들;
}





<이차원 배열>

//선언 및 행, 열 공간할당
자료형[][] 변수명 = new 자료형[행개수][열개수];


//초기화
변수명[행인덱스번호][열인덱스번호] = 값;
...
ㅡㅡㅡㅡㅡ

//선언 및 행 공간할당
자료형[][] 변수명 = new 자료형[행개수][];

//열 공간할당
변수명[행인덱스번호] = new 자료형[열인덱스번호];
...

//초기화
변수명[][] = 값;
...
ㅡㅡㅡㅡㅡ

//단축형식 (선언 및 공간생성, 초기화)
변수명[][] = {{값1, 값2, ...}, 
	{값1, 값2, ...}
}





<메소드 선언>

[접근제어자] [기타제어자] 리턴타입 메소드명([매개변수자료형 매개변수명, ...]){
	실행문들;
	.
	.
	.
	[return 리턴할 값;]
}





<메소드 호출>

메소드명([매개 값...]);





<클래스>

[접근제어자] class 클래스명 {

	[접근제어자] [기타제어자] 자료명 -변수명;
			        -변수명 = 값;
	         예) filnal int MAX = 100;
		int max = 50;
		int[] marr = new int[3];
		String str = " ";
}





<초기화 블럭>

[static] {
	실행문들;

}

[접근제어자] [기타제어자] 리턴타입 메소드명() {
	실행문들;
	[retuen = 값];
}





<생성자>

[접근제어자] 클래스명() {
	실행문들;

}





<객체 선언>

자료형 참조변수명 = new 자료형명();
ㅣ                    ㅣ ; (-선언)	         (-공간할당)
ㅣ	         ㅣ
ㅣ	         ㅣ
클래스급이상    ㅣ
	       (= 객체명, 인스턴스명 -> 주소값 저장)





<생성자호출문>

자료형(=클래스명)([매개변수]);





<import>

import 패키지경로.클래스명;
import 패키지경로.경로.경로...클래스명;





<클래스 다이어그램 기술 순서>

- 속성 기술 순서

접근제어자 기호 속성명 : 자료형 {옵션(final변수라면 readOlny 작성)}
**static은 밑줄을 그어준다.

- 기능 기술 순서
메소드 => 접근제어자 기호 메소드명(매개변수명 : 자료형, ...) : 리턴타입
생성자 => 접근제어자 기호 생성자명(매개변수명 : 자료형, ...)





<String에서 제공하는 메소드(배울때마다 추가)>

- .concat("문자열")
해당 문자열을 문자열객체 뒤에 추가하는 메소드

- .length()
문자열의 길이 메소드

- .trim()
왼쪽 끝과 오른쪽 끝에 있는 공백 제거하는 메소드

- .charAt(값1)
값1에 해당되는 인덱스번호의 문자를 가져오는 메소드

- .substring(값1)
값1에 해당되는 인덱스번호부터 끝까지의 문자열을 가져오는 메소드

- .substring(값1, 값2)
값1에 해당되는 인덱스번호부터 값2 마이너스 1을 한 인덱스번호까지의  문자열을 가져오는 메소드

- .contains("문자열")
해당 문자열이 있는지 묻는 메소드 (리턴타입 boolean)

- .replace(a, b)
a를 b로 바꾸는 메소드

- .replaceAll([aaa], b)
[aaa]에서 a,a,a 하나하나 b로 바꾸는 메소드
**[ ]는 replaceAll에서만 사용가능

- .replaceAll([^aaa], b)
[^aaa]빼고 나머지를 하나하나 b로 바꾸는 메소드
**[ ]는 replaceAll에서만 사용가능





<상속(inheritance)>

확장(extends) : 반드시 부모와 자식이 동급인 경우
ex) 부모(클래스) 자식(클래스) / 부모(인터페이스) 자식(인터페이스)

public class ChildrenClass(자식클래스) extends ParentClass(부모클래스) { }
public interface ChildrenInterface (자식인터페이스) extends ParentInterface (부모인터페이스) { }


실체화(implements) : 부모와 자식이 급이 다른 경우, 인터페이스는 클래스를 상속 받을 수 없다.

public class ChildrenClass(자식클래스) implements ParentClass(부모클래스) { }





<추상클래스>

[접근제어자] abstract class 클래스명 {

	//반드시 필수) public abstract 리턴타입 메소드명([매개변수들...]);

 }





<인터페이스(interface)>

[접근제어자] interface 인터페이스명 {
	[public static final << 숨어있다] 자료형 필드명;
	ex)
	public static final int A = 5;
	int A = 5;	//앞에 public static final 숨어있음

	[public abstract << 숨어있다] 리턴타입 메소드명([매개변수들...]);
	ex)
	public abstract void setA(int a);
	void setA(int a);	//앞에 public abstract 숨어있음
 }





<POJO 기능>

[접근제어자] [기타제어자] class 클래스명 {
	private 자료형 필드명;
	....
	public 리턴타입 getter메소드() {return 값;}
	public void setter메소드(매개변수) {
		맴버필드 초기화 명령문 기술;
		//초기화 명령문 형식
		this.멤버필드명 = 매개변수명;
	}
 }
**이와같은 정해진 형식으로 쓰여져야 기능 사용가능





<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>
<>

http://naver.me/FpZHfhxW




<조건문 형식>

if (조건) {
	실행문들;
}


if () {
	실행문들;
	...;
} else if() {
	실행문들;
	...;
} else {
	실행문들;
	...;
}



switch (케이스값- byte, short, int, char, String) {
case 1: 실행문; 
	break;
case 2: 실행문; 
	break;
case 3: 실행문; 
	break;
default: 실행문;
}



<변수 선언 형식>

//선언만
자료명 변수명;


//선언과 동시에 초기화
자료명 변수명 = 값(리터럴 = Literal);


//자료형이 같은 변수를 동시에 선언 후 초기화
자료명 변수명1, 변수명2, 변수명3;
변수명1 = 값(리터럴);
변수명2 = 값;
...


//자료형이 같은 변수를 동시에 선언 및 초기화
자료명 변수명1 = 값(리터럴), 변수명2 = 값, ...;



<반복문 형식>

//for문
for (초기식; 조건식; 증감식) {
	실행문들;
	...;
}


//for무한반복문
for ( ; ; ) {
	실행문들;
	...;
}


//while문
기준식;
while (조건식) {
	실행문들;
	...
	제어식이나 제어어(break);
}


//while무한반복문
while (true) {
	실행문들;
	...
	제어식이나 제어어(break);
}


//do~while문
기준식;
do {
	실행문들;
	...
	제어식이나 제어어(break);
} while (조건식);


//do~while무한반복문
기준식;
do {
	실행문들;
	...
	제어식이나 제어어(break);
} while (true);



<상수(Constant)>

final 자료형 상수명 = 값(리터럴);
**반드시 대문자로 상수명 기술, 반드시 선언과 동시에 초기화



<배열>

같은 자료형을 가진 여러 개의 요소를 묶어놓은 집합체 형식

//선언
1. 자료형[] 참조변수명; (기본)
2. 자료형 참조변수명[];

//공간생성, 초기화

변수명 = new 자료형[] {값1, 값2, ...};
ㅡㅡㅡㅡㅡ


//선언 및 공간생성(메모리 할당)

자료형[] 변수명 = new 자료형 [방개수];

//초기화 
변수명[인덱스번호(방번호)] = 값1;
변수명[인덱스번호(방번호)] = 값2;
...
ㅡㅡㅡㅡㅡ

//단축형식 (선언 및 공간생성, 초기화)

자료형[] 변수명 = {값1, 값2, ...};
**new가 포함되어 있으며, 처음 설정한 값(요소)의 개수만큼 방 크기가 고정된다.



//new키워드
1. 데이터를 저장할 수 있는 공간을 만들어주세요.
2. 해당 공간에 해당 자료형(참조변수)의 내용을 복사해서 붙여넣어주세요.


//방번호, 방순서 = 인덱스 : 0 ~
//방크기, 방길이 = length



<지역인 경우>

변수와 배열객체의 요소값의 차이점
**변수는 지역일 경우 반드시 초기값 설정이 되어야 한다.
**배열객체는 지역일 경우 값이 없으면 자동으로 초기값 설정이 된다.

//자동 초기화 값

byte, short, int => 0
long => 0L
float => 0.0f
double => 0.0
char => '\n0000' (공백한칸)
String 자료형 포함 모든 참조자료형 => null



<for확장형>

//형식

배열변수
for (자료형 변수명 : 배열객체명) {

}

//예

int[] c = {1, 2, 3, 4, 5};
for (int i : c) {
	System.out.print(i + " ");
}

=> 1 2 3 4 5 




<이차원 배열>

행과 열로 이루어진 배열(바둑판)

//선언 및 행, 열 공간할당
자료형[][] 변수명 = new 자료형[행개수][열개수];


//초기화
변수명[행인덱스번호][열인덱스번호] = 값;
...
ㅡㅡㅡㅡㅡ

//선언 및 행 공간할당
자료형[][] 변수명 = new 자료형[행개수][];

//열 공간할당
변수명[행인덱스번호] = new 자료형[열인덱스번호];
...

//초기화
변수명[][] = 값;
...
ㅡㅡㅡㅡㅡ

//단축형식 (선언 및 공간생성, 초기화)
변수명[][] = {{값1, 값2, ...}, 
	{값1, 값2, ...}
}


//자료형[행][열] => 행 = row, 열 = column












<메소드(method)>

자바의 클래스에서 기능을 처리할 수 있도록 해주는 역할.
**리턴타입 기술부 필수.


//형식 (메소드 선언)

[접근제어자] [기타제어자] 리턴타입 메소드명([매개변수자료형 매개변수명, ...]){
	실행문들;
	.
	.
	.
	[return 리턴할 값;]
}

//메소드 선언 기능

1. 자바의 메소드는 반드시 선언이 되어 있어야 사용가능.
2. 메소드는 무조건 호출을 해야 실행된다.(자동실행x)
**단 main메소드는 JVM이 실행.



//형식 (메소드 호출)

메소드명([매개값...]);


//메소드 호출 기능

1. 메소드를 실행시킴.
2. 리턴 값을 받는 공간.


//메소드 호출 시 지켜야 할 사항

1. 메소드의 이름
2. 메소드의 매개변수 개수
3. 메소드의 매개변수 자료형
4. 메소드의 매개변수 나열순서(선언된 자료형 순서대로, 자료형 개수 만큼)




<메소드 오버 로딩(Over Loading>

동일한(같은) 이름의 메소드를 한 클래스에 여러개 만들어 두는것 (여러개 쌓아두는 것)


//조건

1. 반드시 매개변수의 개수가 달라야함
2. 반드시 매개변수의 자료형이 달라야함
3. 매개변수의 개수와 자료형이 일치하면, 반드시 나열순서가 달라야 한다.
4. 메소드의 이름이 동일해야 한다.




<클래스>

자바에서 데이터를 담기 위한 속성들(변수, 상수, 객체)과 어떠한 명령들을 처리하기 위한 기능들(메소드들, 생성자들, 초기화 블럭)의 집합
자바 파일의 최소 단위
**클래스에 멤버 - 속성, 메소드, 생성자, 초기화블럭 (4개뿐)


//클래스의 형식
[접근제어자] class 클래스명 {

	[접근제어자] [기타제어자] 자료명 -변수명;
			        -변수명 = 값;
	         예) filnal int MAX = 100;
		int max = 50;
		int[] marr = new int[3];
		String str = " ";
}



//초기화 블럭

[static] {
	실행문들;

}

[접근제어자] [기타제어자] 리턴타입 메소드명() {
	실행문들;
	[retuen = 값];
}



//생성자

[접근제어자] 클래스명() {
	실행문들;

}




- 일반 클래스

main 메소드 없음


- 메인 클래스 

main 메소드 있음



- 속성 : 필드, 컬럼, 멤버 변수, 인스턴스 변수, Attribute, property



<변수의 종류>

//생명주기

- 전역변수 

전역에 사용되는 변수
프로그램이 실행되어 선언된 시점부터 프로그램이 종료될 때 까지 살아있는 변수
(멤버변수, 등)

선언만 되어있으면 자동초기화 됨
동일한 이름으로 재선언이 한번 가능함


- 지역변수

지역 내부 안에서만 살아있는 변수
(메소드, 생성자, 반복문, 조건문(제어문))

동일한 이름으로 재선언이 불가능함



객체지향언어 (Object Oriented Programming language)
 자바



<객체선언 형식>

자료형 참조변수명 = new 자료형명();
ㅣ                    ㅣ ; (-선언)	         (-공간할당)
ㅣ	         ㅣ
ㅣ	         ㅣ
클래스급이상    ㅣ
	       (= 객체명, 인스턴스명 -> 주소값 저장)



- 인스턴스 : 원본 클래스 복제 후 메모리에 저장



변수선언 및 값 할당
//변수를 만들 수 있는 자료형: 기본자료형(byte, short, int, long, char, float, double)
자료형 변수명 = 값;

객체선언 및 공간 할당(클래스복제 = 인스턴스)
//객체를 만들 수 있는 자료형
//자바에서 제공해주는 자료형(예: String), 
//우리가 직접 만든 클래스
자료형(class이상) 객체명 = new 자료형(); //자료형() => 생성자호출문





<한 개의 java파일에 여러 개의 클래스를 기술할 때 public키워드를 붙일 수 있는 조건>
**클래스명과 자바파일의 이름이 동일해야한다.
 

- 일반클래스와 메인클래스가 섞여 있는 경우

1. 반드시 여러 개의 클래스 중에서 한 개의 클래스만 public키워드를 붙일 수 있다.
2. 반드시 메인클래스를 선언하는 곳의 접근제어자가 public 이어야 한다.
3. 파일명은 public키워드가 붙어있는 클래스의 이름과 동일해야 한다.


- 일반클래스들만 여러 개가 있는 경우

1. 반드시 여러 개의 클래스 중에서 한 개의 클래스만 public키워드를 붙일 수 있다.
2. 파일명과 동일한 이름의 클래스에만 public키워드를 붙일 수 있다.




<클래스의 멤버로 존재할 수 있는 것>
1. 속성(변수, 상수, 객체)
- 기능
2. 메소드
3. 초기화블럭
4. 생성자



<생성자(Constructor)>

클래스에서 인스턴스(객체)를 생성할 수 있도록 도와주는 기능을 처리함.
**생성자의 목적 : 클래스안의 멤버필드(속성)의 초기화를 진행.

1. 반드시 클래스명과 동일해야 한다.
2. 반드시 리턴타입을 기술하는 기술부 자체가 없다.
3. 객체생성문에서 new키워드 뒤에 호출이 된다.
ex) ExClass ec = new ExClass();
		ㄴ생성자호출문

4. 클래스안에 기술된 생성자가 한 개도 없으면 기본생성자가 숨어있다.
- 숨어있는 기본 생성자 :
	public 클래스명(){}
**숨어있는 기본 생성자의 접근제어자는 public, 직접 기술한 기본 생성자의 접근제어자는 다 가능.


5. 클래스안에 기타생성자가 한 개라도 기술되어있으면 기본생성자는 사라진다.
**기본생성자를 사용하려면 반드시 기본생성자도 기술해줘야 한다.



- default (기본) 생성자 형식 (매개변수가 없음.)

// public 클래스명() {}

[접근제어자] 클래스명() {
	실행문들;

}



- 기타 생성자 형식 (매개변수가 있음.)

[접근제어자] 클래스명([매개변수...]) {
	실행문들;

}





//형식

[접근제어자] 클래스명([매개변수...]) {
	실행문들;

}


vs

(메소드 형식)

[접근제어자] [기타제어자] 리턴타입 메소드명([매개변수...]){
	실행문들;
	.
	.
	[return 리턴할 값;]
}



//생성자 오버로딩 조건

**메소드 오버로딩 조건 모두 포함
**이름은 반드시 클래스명과 동일해야 한다.



//생성자호출문의 기능

1. 클래스를 복제한다. (= 객체생성)
2. 생성자안의 명령문 실행





<this키워드> : 기술할 수 있는 곳 - 메소드안, 생성자안 (순서x)

- this키워드는 반드시 멤버 앞에만 붙일 수 있다
- 단위가 객체이다
- 지역 앞에 붙을 수 없다
- (나를) this키워드를 감싸고 있는 멤버필드의 객체
- (나의) this키워드를 가지고 있는 인스턴스



<this()> 기술할 수 있는 곳 - 생성자안

1. 반드시 나와는 다른 생성자를 호출하는 호출문이어야 한다.
2. 반드시 생성자 안의 맨 처음 명령에 한번만 가능하다. 


//this();
인스턴스 기본생성자 호출문

//this(매개변수);
인스턴스 해당 케이스의 생성자 호출문 




 
- 비교대상이 변수인 경우는 == (동등비교연산자)의 의미는 값을 비교하는 연산자  (변수 - 값을 저장)
- 비교대상이 객체인 경우는 == (동등비교연산자)의 의미는 주소값을 비교하는 연산자 (객체 - 주소값을 저장)





<캡슐화(Encapsulation)> : 바로 노출되는 변수나 객체를 한 번 더 감싸서 직접 노출을 막기 위해 감싸는 것 (감싸는 기본 단위가 클래스)



<정보은닉(Imformation Hiding) = 보안> 
- 외부에서 멤버에 직접 접근을 하지 못하도록 막는 것(숨기는 것).
- 반드시 멤버필드의 접근제어자가 private가 되어야 한다.
- 반드시 멤버필드의 값을 가져오기 위해서는 반환값을 돌려줄 수 있는 public 메소드가 존재해야 한다.
							[default] 메소드도 가능은 하지만, public 권장




<접근제어자(Access Modifier)> : public > protected > default > private   (ppdp)
 


<import키워드>

나와 다른 패키지 안의 클래스나 메소드를 끌어올 때 소속을 명시하는 부분.

//형식

import 패키지경로.클래스명;
import 패키지경로.경로.경로...클래스명;



<객체(Object)> : 자바의 최상위 객체

어떠한 것을 독립적으로 표현할 수 있는 대상





메소드호출문
1. 메소드 실행
2. 리턴값이 있으면 그 값의 저장 공간


생성자호출문
1. 생성자 실행
2. 해당 케이스의 명령문 실행





<기타제어자 (Modifier)>

- final => ~할 수 없는, ~하지 못하는

- static => 정적(고정된), 공유 되는, 객체생성 없이 클래스 이름으로 접근 가능한 
							|
							ㄴ static메소드 안에서 this 대신 클래스 이름

- abstract => 추상적인, 몸체가 없는, 반드시 재정의 해야하는




<static 제어자>

static 키워드를 붙일 수 있는 것 : 멤버필드(속성), 메소드, 초기화블럭, 지역한텐 못씀

(static-멤버로 위장)

static메소드 안에서 멤버필드(속성)나 메소드를  호출, 선언 하려면 static키워드가 붙어있는 애들만 가능



(메모리 영역 - Method = static = class = 정적)





생성문에는 중괄호가 붙는다 / 이때 중괄호를 몸체라고 부름




<싱글톤패턴(Singleton)>
반드시 객체를 한 개만 생성하도록 강제적으로 제한하는 패턴(형식, 정해진것)


//조건
1. 반드시 private static 키워드와, 자료형이 내 자신의 클래스인 => 속성 하나가 선언되어야 한다.
2. 반드시 1번의 필드를 반환해주는 pubilc static 키워드가 붙은 getter메소드가 있어야 한다.
3. 반드시 생성자들의 접근제어자가 private으로 되어야 한다.




<변수들의 생명주기>
- 지역 변수
(탄생) : 지역변수가 선언된 시점
(죽음) : 지역변수가 포함된 메소드나 생성자의 명령이 모두 종료된 후

- 인스턴스 변수
(탄생) : 인스턴스가 선언된 시점(= 객체가 선언된 시점)
(죽음) : 인스턴스가 소멸되는 시점

- static변수 = 클래스변수 = 정적변수
(탄생) : 클래스가 메모리에 올라가는 시점부터(= 프로그램이 실행되는 시점)
(죽음) : 프로그램이 종료되는 시점





<UML(통합 모델링 언어, Unified Modeling Language)>

개발자가 필요한 요소들 정리
요소들의 관계 정리
요소들의 흐름들을 도식화(깔끔하게 양식화) 할때 사용하는 다이어그램

- 클래스 다이어그램 : 클래스, 인터페이스, 추상클래스 들 안에 필요한(속성,기능 정리) 조건 관리
		    해당 요소들간의 관계 정리

- 시퀀스 다이어그램 : 요소들이 어떻게 흐르는지의 절차를 정리




<클래스 다이어그램>

- 속성(변수, 상수, 객체)과 기능(메소드, 생성자)들을 보기 쉽게 정리하는 것
- 사각형으로 그려서 정리한다.
- 기술하는 방법이 정해져있다.





<String>


- String은 고정형 자료형이기 때문에 값이 변경되면 주소값도 변경된다
- String으로 만든 객체는 주소값이 아닌 값을 출력
- String에서 제공하는 모든 메소드는 원본 훼손이 일어나지 않는다


//String에서 제공하는 메소드(배운것들 작성) (String메소드)

- .concat("문자열")
해당 문자열을 문자열객체 뒤에 추가하는 메소드

- .length()
문자열의 길이 메소드

- .trim()
왼쪽 끝과 오른쪽 끝에 있는 공백 제거하는 메소드

- .charAt(값1)
값1에 해당되는 인덱스번호의 문자를 가져오는 메소드

- .substring(값1)
값1에 해당되는 인덱스번호부터 끝까지의 문자열을 가져오는 메소드

- .substring(값1, 값2)
값1에 해당되는 인덱스번호부터 값2 마이너스 1을 한 인덱스번호까지의  문자열을 가져오는 메소드

- .contains("문자열")
해당 문자열이 있는지 묻는 메소드 (리턴타입 boolean)

- .replace(a, b)
a를 b로 바꾸는 메소드

- .replaceAll([aaa], b)
[aaa]에서 a,a,a 하나하나 b로 바꾸는 메소드
**[ ]는 replaceAll에서만 사용가능

- .replaceAll([^aaa], b)
[^aaa]빼고 나머지를 하나하나 b로 바꾸는 메소드
**[ ]는 replaceAll에서만 사용가능

- .indexOf(문자열) : 해당 문자열의 맨 앞글자를 왼쪽에서부터 찾아서 해당 인덱스를 반환함.

- .indexOf(문자열, 인덱스번호) : indexOf(문자열)과 동일한데 해당 인덱스번호를 시작지점으로 인식하여 오른쪽으로 찾는다.

- .indexOf(아스키코드) : 해당 아스키코드 값에 문자를 찾아 인덱스를 반환함.

- .lastIndexOf(문자열) : 해당 문자열의 맨 앞글자를 오른쪽에서부터 찾아서 해당 인덱스를 왼쪽에서부터 세어 반환함.

-.lastIndexOf(문자열, 인덱스번호) : lastIndexOf(문자열)과 동일한데 해당 인덱스번호를 시작지점으로 인식하여 왼쪽으로 찾는다.

- .toUpperCase() : 싹 대문자로

- .toLowerCase() : 싹 소문자로

- .compareTo(문자열) : 문자열 비교, 값을 int로 반환

- .compareToIgnoreCase(문자열) : 비교 문자열의 대소문자를 똑같다 치고 compareTo(문자열) 함



- 패키지(클래스를 묶어놓은 집합체)
- import(다른 패키지를 끌어오세요)
- * (아스테리스크, 전체) 패키지안에 있는 모든 클래스에 import
	ex) import 패키지명.*


<Wraper클래스>

기본자료형을 클래스화 시켜놓은 자료형
String과 마찬가지로 특이클래스, 값이 바뀌면 주소값도 변경된다.

기본자료형 -> Wraper클래스 : Boxing (UpperCase)

Wraper클래스 -> 기본자료형 : Unboxing (LowerCase, DownCase)


숫자<>문자 형변환 할땐 클래스급으로 => (기본자료형 -> Wraper클래스 : Boxing)


기본자료형 <-> Wraper클래스  :  지들끼린 자동형변환 가능.

기본자료형을 Wraper클래스로 만드는 이유 >> 기본자료형의 Wraper클래스에 메소드를 사용하기 위함




<동일한 메소드 : 메소드명, 매개변수명, 매개변수 자료형 이 같은 메소드>



<상속(inheritance)>

나의 기능을 확장(extends), 나의 기능을 실체화(implements, realization)
부모에게서 물려 받은 것을 자식에게서도 사용할 수 있도록 하는것.

부모 : Super, 상위, 기본
자식 : Sub, 하위, 파생

//형식
확장(extends) : 반드시 부모와 자식이 동급인 경우
ex) 부모(클래스) 자식(클래스) / 부모(인터페이스) 자식(인터페이스)
public class ChildrenClass(자식클래스) extends ParentClass(부모클래스) { }
public interface ChildrenInterface (자식인터페이스) extends ParentInterface (부모인터페이스) { }

실체화(implements) : 부모와 자식이 급이 다른 경우, 인터페이스는 클래스를 상속 받을 수 없다.
public class ChildrenClass(자식클래스) implements ParentClass(부모클래스) { }


클래스급이상(클래스, 추상클래스, 인터페이스)인 경우 형변환은 반드시 상속관계에서만 형변환이 가능하다. 
아니면 String <> Wraper클래스 간 메소드를 이용해서 형변환

<상속 - 다형성(polymorphism)>

하나의 객체가 여러개의 자료형을 가지고 있는 것을 말함
=> 상속, 형변환 을 말함 => 필요한 이유는 메모리 낭비를 줄일 수 있다.

부모는 여러 자식을 품을 수 있음
자식은 부모를 품을 수 없음
자식은 지가 다 가질라함 -> 부모 Hiding, 부모꺼 내꺼처럼


<pacha케이스>
같은 이름 속성 : 부모것만		같은 이름 메소드 : 자식것만	(static메소드는 이름 같아도 부모것만)
다른 이름 속성 : 부모것만		다른 이름 메소드 : 부모것만

<chacha케이스>
같은 이름 속성 : 자식것만		같은 이름 메소드 : 자식것만
다른 이름 속성 : 부모자식 모두	다른 이름 메소드 : 부모자식 모두

상속관계에서도 오버로딩이 존재한다.
ex) 
(부)
public void md( ) //Hiding
public void md1(int a) -이놈
(자)
public void md( ) //Overriding -이놈
public void md1(String a) -이놈

이놈들 => 상속관계에서의 메소드 오버로딩




<오버라이딩(Overriding) 오버라이드(Override)>

부모와 자식간에 동일한 이름의 메소드가 존재하는 경우 자식의 메소드로 재정의(덮어쓰기) 되는 현상
(해당 메소드의 부모의 접근제어자 이상의 접근제어자를 사용해야 함)



부모와 자식관계에서 동일한 이름의 메소드가 있는 경우(매개변수까지 같은 동일 메소드)
부모 메소드가 가려지고(Hiding) 자삭의 메소드로 재정의(덮어쓰기) 되는 현상

//조건 
1. 반드시 상속관계가 존재해야 한다
2. 반드시 부모와 메소드가 동일해야 한다(매개변수까지 같은 동일 메소드)
3. 반드시 접근제어자가 부모 이상의 접근제어자로 선언되어야 한다
4. *********반드시 재정의(덮어쓰기) 되기 위해서는 리턴타입까지 동일해야 한다 (2번이랑 같은 말)

*private 처리된 부모의 속성은 상속되지 않는다




<Super키워드>

상속관계가 있을 때 부모 클래스에 호출(접근)하는 키워드
this키워드와 조건이 비슷함

super키워드 : 부모 인스턴스

super( ) 호출문 : 부모 인스턴스 안의 기본생성자 호출(자동으로 숨겨있다)
**자동으로 숨겨진 부모의 기본생성자는 실행되는 자식의 생성자 중 마지막으로 실행되는 생성자의 처음 명령에 숨어있다  *****마지막으로 실행되는 생성자*****
(단, 부모클래스에 기타생성자만 기술되어 있으면 오류 이럴경우 부모클래스에 기본생성자 기술하면 오류x)

super(매개변수) 호출문 : 부모 인스턴스 안의 해당 케이스의 기타생성자 호출(반드시 기술 해야한다.)






<상속의 캐스팅>

(상위 = <하위)
업캐스팅, 상위 자료형 생략가능, new한테도 업캐스팅 가능, 
하위는 상위의 자식자료형이여야 함

(하위 = <상위)
다운캐스팅, 하위 자료형 생략안됨, 상위 new한테는 다운캐스팅 불가능, 
하위는 상위의 자식자료형이여야 함


import키워드 - 다른 package를 사용하기 위한 - import 패키지명.패키지명....
package키워드 - class들의 소속 - package 패키지명




<추상클래스>

구현부(몸체)가 없는 메소드를 하나 이상 가지고 있는 abstract 키워드가 있는 클래스를 말함

- 키워드이며 기타생성자
- 클래스와 인터페이스 중간다리

//형식
[접근제어자] abstract class 클래스명 {

	//반드시 필수) public abstract 리턴타입 메소드명([매개변수들...]);

 }

//조건

1. class 정의시 abstract키워드가 붙어있어야 한다.
2. abstract클래스(추상클래스)는 반드시 abstract메소드를 한개 이상은 꼭 가지고 있어야 한다.
3. abstract메소드는 반드시 상속받은 자식클래스에서 재정의(Override)가 이루어져야 한다.
(자식클래스에서 재정의 되는 부분에는 몸체구현을 해야하며, abstract키워드가 제거된다.)
4. 객체생성을 할 수 없다. (생성자가 없는것이 아님)
(생성자, 메소드, 멤버필드 모두 가질 수는 있다.)
5. 객체생성 시 자식클래스로 생성 해야 한다.


<@(At기호)> : 어노테이션(Annotation) : 특수한 기능을 가진 주석

//형식
@명령이름





<인터페이스(Interface)>

추상메소드, 상수만 가지고 있는 집합체(묶음)

- 멤버필드에 변수는 상수만 있기 때문에 초기화까지 해줘야함


//형식

[접근제어자] interface 인터페이스명 {
	[public static final << 숨어있다] 자료형 상수명 = 값; //초기화까지 하거나, 선언만.
	ex)
	public static final int A = 5;
	int A = 5;	//앞에 public static final 숨어있음

	[public abstract << 숨어있다] 리턴타입 메소드명([매개변수들...]);
	ex)
	public abstract void setA(int a);
	void setA(int a);	//앞에 public abstract 숨어있음
}



//인터페이스의 조건
기능을 쉽게 바꿀 수 있도록 하기 위함.
보안을 위함.

1. 멤버필드는 반드시 public static final 상수만 가능
2. (권장) 메소드는 반드시 public abstract 메소드만 가능
3. 생성자를 가질 수 없다.
4. abstract 메소드는 반드시 자식클래스에서 재정의(Override) 되어야 한다.
5. 객체생성 시 자식클래스로 생성 해야 한다.



//인터페이스의 목적
1. 기능을 쉽게 바꿀 수 있다.(= 코드수정 용이. = 가독성이 좋다.)
2. 보안을 위해
***3. 다중 상속을 위해




//extends, implement

extends - 같은 급인 경우 사용하는 키워드
ex)
1. 자식클래스 extends 부모클래스
2. 자식클래스 extends 부모추상클래스
3. 자식인터페이스 extends 부모인터페이스


implement - 다른 급인 경우 사용하는 키워드
ex)
1. 자식클래스 implement 부모인터페이스
2. 자식추상클래스 implement 부모인터페이스
***인터페이스는 클래스를 상속 받을 수 없다 





상속자식에서 재정의시
abstract키워드는 사라짐
접근제어자가 부모이상의 접근제어자가 되어야함
반드시 몸체(구현부)가 있어야함




<Template Method>
GOF패턴(gang of four)
**형식이 정해져 있는 메소드를 말함
GOF패턴중 상속자식에서 재정의 하는 메소드의 양식을 변경할 수 없는 것은 행위패턴 중 하나



<POJO(Plain Old Java Object)>
기존의 순수한 자바 객체

//조건
1. 멤버필드가 (권장)private 처리 되어야 한다
2. 멤버필드의 값을 설정하거나 얻어갈 수 있는 접근제어자가 public인 gatter, setter 메소드가 존재해야 한다

//형식
[접근제어자] [기타제어자] class 클래스명 {
	private 자료형 필드명;
	....
	public 리턴타입 getter메소드() {return 값;}
	public void setter메소드(매개변수) {
		맴버필드 초기화 명령문 기술;
		//초기화 명령문 형식
		this.멤버필드명 = 매개변수명;
	}
 }



인터페이스끼리 상속관계일땐 오버라이드 불가능, 안해도됨, 못함 
=> 이유는 인터페이스가 abstract메소드만 가질 수 있기 때문. abstract메소드는 몸체가 없어서 안됨

인터페이스의 자식클래스에서 오버라이드 할때 다중상속(다형성)되어 있는 부모급 인터페이스들의 모든 abstract메소드를 오버라이드 해줘야함


<인터페이스의 기타생성자, private>
인터페이스에서 default, static 기타생성자의 기능은 조금 다름
접근제어자인 private의 기능도 조금 다름

- 인터페이스에서의 static키워드
1. 인터페이스의 statica메소드 또한 오버라이드 되지 않으며, 반드시 인터페이스명으로(해당 static메소드 앞에 인터페이스명.으로) 접근가능
(또한이라 한 이유는 클래스의 상속관계에서도 static메소드는 오버라이드 되지 않았다)
2. (자료형이 인터페이스인 객체)의 객체명으로는 접근불가
3. 상속받은 자식에서 재정의 하지 않아도 사용가능 하다

- 인터페이스에서의 default키워드(기타제어자로 사용)
1. 인터페이스에 선언된 default메소드에는 앞에 public을 기술해줘야한다
(public default로 기술, 메소드 앞에 아무것도 안쓸경우 인터페이스에선 //public abstract가 숨어있기 때문에 default를 쓰고싶으면 public default로)
2. 상속받은 자식에서 재정의 하지 않아도 사용가능 하다


- 인터페이스에서의 private키워드

1. 인터페이스의 private메소드는 상속 불가능, 재정의 불가능
2. 따라서 동일한 메소드(메소드명, 매개변수명, 매개변수 자료형 이 같은 메소드)가 존재해도
   별도의 독립적인 영역의 메소드로 인식한다.
   (같지만 같은 메소드가 아닌거)
   (pacha케이스에서 동일한 메소든데 부모메소드에 private처리가 되어있으면 같지만 다른메소드, 다른메소드로 인식해서 자식메소드 Hiding, 부모메소드는 private라서     외부접근 불가능)






<java.lang.String 메소드 추가>
 - .forName( 문자열 )
문자열 << 이 클래스의 패키지명.까지 다 붙여야 됨
문자열 << 이 클래스에 대한 정보를 알려줘, (ex)드라이버설치)
외부라이브러리를 사용하는 메소드

 - .toGenericString()
더 자세히

 - .toString()
오브젝트가 가지고 있는 메소드
모든 자식클래스에서 오버라이드해서 사용가능
재정의는 무조건 문자열로 출력 될 수 있게
 .앞의 해당클래스에 재정의해서 사용
 .앞의 해당클래스에 toString()메소드가 있는 경우 >> .앞의 해당클래스명을 출력하면 toString()메소드가 호출되고 리턴값 출력


 - 문자열객체명.split("구분자"[, 숫자값])
숫자값이 없는 경우 : nolimit = default (배열로 나누면서 연속적으로 끝까지 아무 값도 없는 경우는 배열에서 제외 됨)
	default는 0임
=> 해당 구분자를 기준으로 문자열 객체를 하나씩 나누어 문자열 배열 형태(반환타입 String[ ])로 만든다.
=> 해당 구분자는 삭제된다.
숫자값이 있는 경우 : (범위 지정 => (인덱스 - 1)배열까지)의 String[ ]로 나눈다.


 - .getChars(복사할 객체의 시작인덱스번호(int), 복사할객체의 마지막인덱스-1(int), 복사해서 붙여넣기 할 객체명, 붙여넣을 객체의 시작 위치 인덱스번호(int))
 매개변수 4개
 



<java.lang. 안에 유용한 메소드들>
 - Character.is~~()메소드들은 해당 요소에서 작은따옴표를 제외하고 안의 값만 그대로 가져와서 비교한다.
	~~에는 Digit, Letter, UpperCase, 등이 있음

 - Math.random()
숫자0과 숫자1 사이의 실수(0.~) 반환
(ex)
(Math.random() * a) + b
b부터 a까지 사이의 실수
정수로 받고 싶으면 메소드 앞에 (int)로 형변환

 - Math.abs(a) 
a의 절대값

 - Math.ceil 
무조건 올림처리

 - Math.floor 
무조건 내림처리

 - Math.rint   
반올림 처리

 - Math.max(a, b) 
a와b 중에 큰 값

 - Math.min(a, b) 
a와b 중에 작은 값







<java.util. 안에 유용한 메소드들>


 - random.nextInt()
int num = random.nextInt();
nextInt에 값 지정이 안되면 int의 유효범위 내의 정수가 임의 출력	//0포함

(ex)
int num = random.nextInt(11); 
//0부터 11개 >> 0 ~ 10 
//nextInt(a) a는 양수만 가능


float f = random.nextFloat();
0.0부터 1.0 사이의 임의의 실수 값


boolean b = random.nextBoolean();
임의의 논리값





//스캐너패키지 메소드
//가변형 자료형 StringBuffer
//Arrays클래스 메소드 >> 원본훼손 일어나는 메소드, 원본훼손 일어나지 않는 메소드









<초기화블럭(initializaion Block)>

필드(=속성=필드=인스턴스=Attribute=Property=컬럼=column)의 값을 초기화 시키는 기능을 가지고 있는 블럭

//형식
- 인스턴스 필드 블록 형식 : {필드의 초기화명령문; (static필드, 인스턴스필드)}
- 클래스 필드 블록 형식 : static{ 필드의 초기화명령문; (static필드)}

//초기화 순서
1번. 필드의 자동초기화값
2번. 필드선언 시 초기값 바로 대입하는 경우(명시적 초기화)
3번. 인스턴스 필드 블록 초기화값
4번. 클래스 필드(static필드) 블록의 초기화값
5번. 생성자에서 초기화한 값 
6번. setter메소드로 초기화한 값(단, setter메소드는 자동실행 안됨. 실행하려면 반드시 호출해야 함)

(ex)
class Ex {
	static int a = 10;	(1번) 명시적초기화
	{ a = 20; }	(2번) 인스턴스필드 초기화블록
	static { a = 55;}	(3번) 클래스(static)필드 초기화블록
	Ex() {
	a = 77;		(4번) 생성자 초기화
	}
 }



***멤버필드를 초기화 할 수 있는 방법

- 초기화 블럭 사용
- 생성자 사용 (this.머시기로)
- setter메소드 사용
- 명시적초기화 (선언과 동시에 값 대입을 하는 방법)

(명시적초기화 ex)
class Ex {
 int a = 1; //명시적초기화
 }


**필드(=멤버=속성=Attribute=property=컬럼=인스턴스 또는 클래스) 상수 예외사항
- 반드시 선언과 동시에 초기값 설정을 해주어야 하나, 생성자와 초기화블럭 중 딱 한 번은 초기값 설정을 할 수 있다.

(생성자로 상수 초기화 ex)
class Ex {
 	final int MAX; //만 하면 에러이지만
Ex() {
  	MAX = 10; //이걸로 한번은 가능(생성자)
	}
 }

(초기화블럭으로 상수 초기화 ex)
class Ex {
 	final int MAX; //만 하면 에러이지만
{
  MAX = 10; //이걸로 한번은 가능(초기화블럭)
	}
 }




<접근제어자(Access Modifier)와 기타제어자(Modifier)>

접근제어자 : public, protected, default, private
기타제어자 : final, static, abstract


//사용가능 범위 정리
===================================================
- 지역변수    : 접근제어자 모두 안됨, 기타제어자는 final만 가능
- 멤버필드    : 접근제어자 모두, 기타제어자는 abstract제외한 모두
- 메소드	     : 접근제어자 모두, 기타제어자 모두
- 생성자	     : 접근제어자 모두, 기타제어자 모두 안됨
- 초기화블록 : 접근제어자 모두 안됨, 기타제어자 static만 가능
- 클래스	     : 접근제어자 public, default, 기타제어자 static만 제외하고 가능
	      (단, 이너(inner) 클래스경우 예외)
===================================================

**같이 쓸 수 없는 제어자들
private 와 abstract
//abstract는 상속관계에서 쓰이는데 private는 같은 클래스 아니면 안보이니까 안됨
final 과 abstract
//abstract는 상속관계에서 쓰이는데 상속관계에서 final은 상속 할 수 없는 이란 뜻이라 안됨
static 과 abstract
//static은 공유되는 인데 abstract는 몸체가 없어서 공유고 뭐고 안됨




<제네릭타입(=지네릭타입=Generic Type)>
클래스, 메소드 에 가능
<>필수
사용자가 제네릭타입을 만드는 ex) class Ex<A> { 머시기 }

//형식
class 클래스명<클래스이상급자료형의 변수명(권장.대문자)>{
	클래스이상급자료형의 변수명 a;
	public 클래스이상급자료형의 변수명 getA() {
		return a;
	}
	public void setA(클래스이상급자료형의 변수명 a) {
		this.a = a;
	}
 }



<권장하는 제네릭타입>
 T => 한 개의 자료형을 변경하고자 하거나 어떤 변수를 지정할 지 잘 모르는 경우는 대개 T변수를 쓴다. (자료형을 의미하는 Type의 약자에서 따온 명칭)
 E => 배열처럼 나열하는 목록의 자료형을 가지는 클래스의 요소 자료형을 지정 할 때 사용하는 명칭(Element의 약자에서 따온 명칭) 
 K => Key요소의 자료형을 지정하는 명칭
 V => Value의 요소의 자료형을 지정하는 명칭
 N => Number자료형을 지정하는 명칭


<제네릭타입에서 <?> = 와일드카드>

? => 와일드카드 : 전체 다, 무엇이든지 => *(아스테리스크) 같은 놈





<컬렉션프레임워크(Collection Framework)>
한꺼번에 많은 데이터들을 처리하기 위한 구조, 형식을 제공하는 것. (배열같은)

//컬렉션프레임워크 형식
(자료형명<자료형명>) <- 자료형
ex) List<Car>
**컬렉션프레임워크는 제네릭기반의 자료형이므로 반드시 요소(제네릭타입)의 자료형은 클래스급 이상의 자료형으로 지정해 주어야 한다.


상속관계의 인터페이스로 되어있음

인터페이스 
	Collection인터페이스가 조상 인터페이스임
 - List인터페이스 -> ArrayList클래스, LinkedList, Vector, Stack, Queue(큐)
	=> 배열객체가 보완되어 나온 자료형, 방구조를 변경할 수 있다
	=> 중복값을 가질 수 있다. => 인덱스가 있기 때문에 (순서가 있다)	(ex. 0번인덱스에 1이 있어도 1번인덱스에 1을 담을수 있음)

	Collection인터페이스가 조상 인터페이스임
 - Set인터페이스 -> HashSet클래스, TreeSet클래스
	=> 리스트와 비슷하지만 중복값을 가질 수 없다.
	=> 순서가 없다. (인덱스가 존재하지 않음)

	Iterator(반복자)인터페이스가 조상 인터페이스임.
 - Map인터페이스 -> HashMap클래스, TreeMap클래스
	=> 키(key)와 값(value)의 쌍으로 이루어진 자료형 //<>제네릭타입을 두개 해줘야함 <하나 key꺼, 하나 value꺼>
	=> 키는 무조건(권장) 문자열자료형(String)으로 지정해 준다.
	=> 중복값을 가질 수 있지만, 중복키는 불가능하다.
	=> 순서가 없다. (인덱스가 존재하지 않음)






//18
//노트필기
//컬렉션프레임워크에 추가
//
//



<Collection Framework 종류와 형식>

- Collection인터페이스를 상속받은 자식 interface : List, Set
- Iterator인터페이스를 상속받은 자식 intetface : Map


List 인터페이스를 상속받은 자식 클래스 : ArrayList : 순서가 있다.(인덱스 존재, 중복값 허용)

//형식
List<자료형> 객체명 = new ArrayList<자료형>();
List<자료형> 객체명 = new ArrayList<자료형>([값(요소), 값(요소)2, 값(요소)3, ...]);
ArrayList<자료형> 객체명 = new ArrayList<자료형>();

//값(요소)추가 : 
- .add(추가할 값)메소드 : 마지막에 값을 추가한다.
- .add(인덱스번호, 추가할 값)메소드 : 해당 인덱스에 값을 추가하고 기존의 인덱스번호부터 ~ 마지막인덱스까지 한 칸씩 뒤로 밀린다.

//값(요소)삭제 : 
- .remove(인덱스번호) : 해당 인덱스의 값을 삭제한다.
- .remove(값) : 처음 인덱스부터 순서대로 검색하여 처음 해당되는 값만 삭제한다.
(중복값이 존재하는 경우는 맨 처음 값만 제거됨)

//해당값(요소) 모두 제거
- .removeAll(컬렉션프레임워크자료형객체) : 해당 자료형으로 지정해둔 값(요소)과 일치하는 값이 있으면 모두 제거함. 
---------------------------------------------------------------------------------
***컬렉션프레임워크자료형객체
*ex)
ArrayList<String> aAList = new ArrayList<String>();
aAList.add("홍길동");
aAList.add("고길동");
aAList.add("마이콜");
aAList.add("홍길동");

ArrayList<String> bAList = new ArrayList<String>();
bAList.add("홍길동");
aAList.removeAll(bAList); // aAList객체에서 홍길동이라는 이름이 모두 제거됨.
---------------------------------------------------------------------------------
- .clear() : 해당 객체를 주소값만 제외한 안의 방을 모두 제거함 



Set자료형 : 순서가 없는 자료형
(인덱스없음 = 중복값 불가)

//형식
Set<자료형> 객체명 = new HashSet<자료형>();
HashSet<자료형> 객체명 = new HashSet<자료형>();
- 순서가 있는 것 처럼 보이도록 처리할 수 있는 자료형 : LinkedHashSet자료형

//방추가 : List자료형과 동일
//방제거 : remove(값) 또는 remove(객체명)으로 제거 가능




Map자료형 : 순서가 없으며, 키와 값의 쌍으로 이루어진 자료형
(키는 중복값 불가, 값은 중복값 가능)
(키, 값에 null값 사용가능, 단 예외 자료형은 제외)

//형식
Map<키자료형, 값자료형> 객체명 = new HashMap<키자료형, 값자료형>();
HashMap<키자료형, 값자료형> 객체명 = new HashMap<키자료형, 값자료형>();
- 순서가 있는 것 처럼 보이도록 하는 자료형 : LinkedHashMap
- 키와 값에 null값을 허용하지 않는 자료형 : Hashtable

//추가 : .put(키명, 추가할 값);
//변경 : .put(키명, 변경할 값);
**키 중복이 허용되지 않으므로 키가 존재하지 않으면 put은 insert기능
**키가 존재하면 put은 update기능으로 처리됨.



=================================================
<객체의 크기(방길이, 문자개수, 행개수, 등등)를 나타내는 키워드 또는 메소드>

 - 배열객체의 방길이 : length
 - 문자열 길이(개수) : length( ) 메소드 
 - 컬렉션프레임워크 객체의 크기 : size( ) 메소드
=================================================


Iterator 인터페이스 자료형 : 한줄로 나열된(순서가 있던 없던 상관없음 - List, Set 가능) 데이터를 하나씩 떼어서 반복해서 가져올 수 있는 자료형 (StringTokenizer처럼)
- .hasNext() : 다음 요소가 있는지 확인, 데이터를 가져오지 않음. (boolean값으로 유무(true, false) 반환)
- .next() : 다음의 요소 한 개를 가져옴. 해당 값을 반환함

//형식
Iterator<자료형> 객체명 = 한줄로나열된객체명.iterator();
**제네릭형식으로 자료형을 반드시 기술해주어야 하나씩 요소를 떼어올 때 쉽게 가져올 수 있다.





<익명 클래스(Anonymous)>

- Inner class로, 이름이 없는 클래스를 말한다.
- 클래스 정의와 동시에 객체를 생성할 수 있다.

- Inerface, AbstractClass 모두 익명 클래스로 객체를 만 수 있다.
부모 클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의하기 때문에 하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없다. 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.

- 이름이 없기 때문에 생성자도 가질 수 없다.
- 인터페이스와 추상클래스 내부의 모든 추상메소드를 반드시 오버라이딩 해야 함.

- 마지막 }(종료중괄호) 뒤에 종료 ;(세미콜론)을 꼭 넣어준다. (매개변수로 생성하는 익명클래스는 종료세미콜론 없어도 됨)
- 외부에서 익명클래스의 멤버필드에는 접근불가.

- 익명클래스 내부에 기술가능한 static의 경우 : 
	1. static final로 선언된 상수(일반 변수 static은 불가)
	2. 외부 변수는 Effectively final나 final만 가능
	**Effectively final : 외부에 일반 변수라도 값 변경이 전혀 안 된 변수

//익명 클래스를 사용하는 이유
- 프로그램 내에서 한 번만 객체를 만드는데 사용되는 클래스를 굳이 정의할 필요가 없기 때문
- AWT, SWING, GUI, 이벤트 처리에 쓰임
- 외부에서 익명클래스의 멤버필드에 접근이 안되므로, 클래스 안에서 모두 처리되어야하는 경우만 익명클래스를 사용한다.

//형식
new 부모클래스이름( ) {
	//익명클래스 기술
 };

//형식2
new 구현인터페이스이름( ) {
	//익명클래스 기술
 }



<이너클래스(inner Class)>
내부클래스

클래스 안이나 메소드 안에 선언된 또 다른 클래스를 말함.
- 클래스를 선언 시 static 제어자를 사용 할 수 있다. (멤버의 개념)
- 클래스를 선언 시 접근제어자 모두 사용 할 수 있다.


//종류
- 인스턴스(instance) 내부 클래스 
클래스의 멤버 위치에 선언된 일반 클래스
외부에서 접근 할 수 있다.

- static 내부 클래스 
클래스의 멤버 위치에 선언된 static 클래스
외부에서 접근 할 수 있다.

- 지역(local) 내부 클래스 
메소드 안에 선언된 클래스
외부에서 접근 할 수 없다.



<람다식 함수>
- 이름 없는 함수
- 함수의 구현과 호출만으로 프로그램을 만들 수 있는 방식이다.
- 인터페이스만 이용 가능

- 외부에 정의된 변수를 참조할 때, final, 또는 Effectively final변수만 가능하다.
- 함수 내부에서 지역변수 선언시 final, 일반 변수만 가능, static불가
- 인터페이스 메소드를 참조하여 만들 경우 해당 인터페이스 내부에는 메소드가 한 개만 선언되어 있어야 한다. 여러 개 인 경우 에러 발생

- 람다식 메소드는 호출되면 익명클래스가 자동으로 생성된다. (눈에는 보이지 않음)
- 마지막 }(종료중괄호) 뒤에 종료 ;(세미콜론)을 꼭 넣어준다
- 자바 8버전부터 지원됨

//문법
(매개변수목록) -> {함수몸체};
한 줄 명령인 경우 중괄호 생략이 가능

리턴타입 메소드명(매개변수....){
 실행코드들....;
 }






<예외처리(Excetpion)>
예측가능한 에러를 정상종료가 되도록 처리하는 방법

Exception클래스 : 예외처리의 최고 조상 클래스(자료형)

//예외처리 방법
1. 책임감이 강한형식 :  try ~ catch문(짝, 반드시 같이 존재해야 함)
try문에서 발생된 에러는 catch문에서 해결함. 내가 발생시킨 에러를 내가 처리함

try문 : 해당 실행문들을 감싸는 위치에 존재
catch문 : try문에서 발생되는 에러를 처리하는 명령문을 감싸는 위치에 존재함

//형식
try {
       실행코드들;
        ...;
} catch (예외처리자료형명 객체명) { **//System.out.println(객체명); = 예외처리자료형명의 (패키지경로 포함)경로: 에러내용
    //try문에서 에러가 발생될 경우 처리할
      실행코드들;
      ...;
}[ finally{
에러가 발생이 되든, 발생이 되지 않든 반드시 try ~ catch문이 실행된 후 마지막에 실행되는 부분의 코드들을 기술;
} ]



2. 책임 전가형식 : throws
- 메소드를 호출한 곳에서 에러를 처리하도록 책임을 전가함
- 위치는 메소드 선언문의 () 소괄호 뒤에 존재함

//형식
[접근제어자] [기타제어자] 리턴타입 메소드명([매개변수들...]) throws 예외처리자료형명, ... {
	실행코드들...;
 }




<입출력 라이브러리는 java.io패키지에서 제공됨>

스트림 : 단방향으로 흐르는 데이터의 흐름을 스트림이라고 함.

바이트 스트림 : 그림, 멀티미디어, 문자 등 모든 종류의 데이터를 입출력할 때 사용
- 바이트코드화, 메모리 효율 좋음, 인코딩 등 해야 내가 알아볼 수 있음
문자 스트림 : 문자만 입출력할 때 사용
- 메모리 효율 안좋음, 내가 바로 알아볼 수 있음


바이트 스트림의 최상위 클래스 : InputStream(입력), OutputStream(출력)
하위 클래스 : 예) FileInputStream, FileOutStream

문자 스트림 최상위 클래스 : Reader(입력), Writer(출력)
하위 클래스 : FileReader, FileWriter



<스트림 : 단방향으로 흐르는 데이터의 흐름>

FileWriter => 문자열이나 char[]배열로 값 입력시 FileReader 객체를 통해 바로 읽어 들일 수 있다.

FileWriter로 입력을 하더라도 byte코드 한 개 한 개 입력하여 작성하는 경우는 반드시 byte코드를 문자스트림방식으로 변환해서 읽어야만 한다.

FileOutputStream => 바이트코드로 파일을 생성할 수 있다.

FileInputStream => 바이트코드로 파일을 읽어들일 수 있다. 바로 문자로 출력이 어렵기 때문에 InputStreamReader를 통해 문자스트림형식으로 변환 후 출력 가능하다.

FileOutputStream을 이용해서 파일을 작성할 때 인코딩을 설정하여 작성하는 경우 반드시 File을 읽어들일 때도 인코딩을 설정해서 읽어주어야 한다.





<프로세스(Process)와 스레드(Thread)>

프로세스 : 실행하고 있는 프로그램 또는 실행한 프로그램이 메모리에 올라와있는 상태를 프로세스라고 함

 - 단일프로세스 : 하나의 프로그램 당 하나의 프로세스만을 가지고 있는 것
	장점 : 메모리를 많이 차지 하지 않음, 속도가 빠름
	단점 : 하나의 프로세스에 문제가 발생하면 프로그램이 종료 됨

 - 멀티프로세스 : 하나의 프로그램 당 여러 개의 프로세스를 가지고 있는 것
	장점 : 하나의 프로세스에 문자가 발생되도 프로그램이 전체적으로 영향을 받지 않는다, 독립적으로 작업이 진행 됨
	단점 : 메모리를 단일프로세스보다 많이 차지함, 속도가 느릴 수 있다.
	예) 크롬브라우저

스레드 : 프로세스(프로그램) 안에서 실행되는 하나의 작업 단위를 스레드라고 함
하나의 스레드에서 문제가 일어나면 다 멈춤

 - 단일스레드 : 프로세스 안에 하나의 스레드만 존재함
	장점 : 메모리를 많이 차지 하지 않는다.
	단점 : 멀티작업을 진행하는 경우에는 멀티스레드보다 속도가 느릴 수 있다.

 - 멀티스레드 : 프로세스 안에 여러 개의 스레드가 존재함
	장점 : 멀티작업을 진행하는 경우에는 단일스레드보다 속도처리가 빠를 수 있다.
	단점 : 단일스레드보다 메모리를 많이 차지 한다.



자바에서는 기본적으로 한개의 스레드를 가지고 있다. (대표적 : main메소드)




<네트워크 필기>

v 인터넷 : 지역네트워크를 통신으로 연결한 것
v 네트워크 란 : 여러대의 컴퓨터들을 통신회선으로 연결한 것. 그물망처럼 연결된 통신망을 말함


v 네트워크 종류 : 
- PAN (Persnal Area Network) : 가장 작은 규모의 네트워크. 예시 : bluetooth
- LAN (Local Area Network) : 근거리 영역 네트워크. 예시 : Wi-Fi
- MAN (Metropolitan Area Network) : 대도시 영역 네트워크. 예시 : 대학교내의 통신망
- WAN (Wide Area Network) : 광대역 네트워크. 예시 : 핸드폰5G망 등
- VAN (Value Area Network) : 공중 통신 사업자로부터 통신 회선을 임대하여 하나의 사설망을 구축하고 이를 통해 정보의 축적, 가공, 변환 처리 등 부가 가치를 첨가한 후 불특정 다수를 대상으로 서비스를 제공하는 통신망
예시 : 은행 간 현금인출기 공동이용 서비스, 신용카드 정보 시스템, 국내외 항공사 간 항공권 예약 서비스
- ISDN (Integrated Services Digital Network) : 종합정보 통신망(=BISDN) 전화, 데이터 통신, 비디오텍스 등 통신관련 서비스를 종합하여 다루는 통합서비스 디지털 통신망. 디지털 전송방식과 광섬유 케이블 사용.


v 프로토콜(protocol) : 통신을 주고 받기 위한 통신 규칙. 컴퓨터와 컴퓨터도 서로 이해 할 수 있는 언어, 공용된 언어를 사용 해야 한다는 것


	v IP(Internet protocol address)(집주소-아파트(ip)) : 네트워크상에서 장치들이 서로 통신을 하기 위한 규칙에 필요한 서로를 식별하기 위한 고유 주소 또는 특수번호를 말함. (집 주소처럼 컴퓨터 주소라고 보면 됨. 하나의 랜카드 당 한 개의 ip가 할당되어 있다.)
**랜카드 : 네트워크를 사용하기 위한 어댑처 역할을 하는 장치
- IP는 흐름에 관여하지 않기 때문에 보낸 정보가 제대로 갔는지 보장하지 않는다. 전송과정에서 패킷이 손상될 수도 있고, 같은 호스트에서 전송한 패킷의 순서가 뒤죽박죽이 될 수도 있고, 같은 패킷이 두 번 전송될 수도 있으며, 아예 패킷이 사라질 수도 있기 때문에 패킷 전송과 정확한 순서를 보장하려면 TCP프로토콜과 같은 IP의 상위 프로토콜을 이용해야 한다.


	v 전송 제어 프로토콜(Transmission Control Protocol, TCP, 문화어: 전송조종(제어)규약(규칙)) : 웹 브라우저들이 월드 와이드 웹(www-대부분 웹이라고 함)에서 서버에 연결할 때 사용되며, 이메일 전송이나 파일 전송에도 사용된다.


v 포트(port)(집주소-아파트(ip) 동호수(port)) 란 : 같은 ip에서 접근해야하는 프로그램이 여러개 일 경우 해당 프로그램에 대해 접근하기 위해 부여된 프로그램 주소값이라고 생각하면 된다.


v 서버 : 서비스를 제공하는 프로그램을 의미함 (서비스를 제공하는 역할)
v 클라이언트 : 서비스를 요청하고, 받는 프로그램을 의미함 (서비스를 요청하고 받는 역할)
v 소캣(Socket) : 프로그램이 네트워크에서 데이터를 통신할 수 있도록 연결해주는 연결부


v ServerSocket 클래스(서버측) :
- java.net패키지에서 제공
- 서버 프로그램을 개발할 때 쓰이는 클래스
- 서버를 구동 시킬때, 요청을 받기위한 준비를 할때 사용
- 서버를 구동 시키는 것이므로 ip주소는 필요없으며, 자신의 서버에 제대로 접근할 수 있는 포트번호만 있으면 된다.
예시 : ServerSocket echoServer = new ServerSocket(4000); //4000이 포트번호임.

v Socket클래스(클라이언트측/서버측) :
- java.net클래스에서 제공
- client에서 서버로 접속하거나 Server에서 요청을 accept(수락)하는데 필요한 클래스
- 서버에 접근을 해야하므로 해당 서버의 ip주소와 해당 서버내의 프로그램이 부여받은 포트번호까지 필요하다.
예시 : Socket socket = new Socket("127.0.0.1", 4000);
	//서버의 ip주소: "127.0.0.1" , 서버의 포트번호: 4000
- 클라이언트의 요청을 수락해야하므로 Socket으로 요청한 자료형과 일치되는 Socket자료형으로 accept(수락)해주어야 함.
예시 : Socket socket = echoServer.accept();


v TCP/IP 송수신 과정
1. 서버 : 클라이언트의 요청을 받기 위한 준비를 한다. (ServerSocket)
   ServerSocket echoServer = new ServerSocket(4000);

2. 클라이언트 : 서버에 접속 요청을 한다. (Socket)
   Socket socket = new Socket("127.0.0.1", 4000);
2. 서버 : 클라이언트의 요청을 받아 들인다. (accept)
   Socket socket = echoServer.accept();

3. 클라이언트 : 서버에 메시지를 보낸다. (BufferedWriter)
3. 서버 : 클라이언트가 보낸 데이터를 출력한다. (BufferedReader)

4. 서버 : 클라이언트에에 메시지를 보낸다. (BufferedWriter)
4. 클라이언트 : 서버가 보낸 데이터를 출력한다. (BufferedReader)

5. 서버, 클라이언트 모두 종료 : 종료 한다. (socket.close())


v InetAddress 클래스
- InetAddress 클래스는 IP주소를 표현한 클래스임
- ip주소뿐만 아니라 도메인을 이용하여 ip정보를 가져올 수도 있다
- 자바에서는 모든 IP주소를 InetAddress 클래스를 사용한다
- default로 된 생성자가 하나 존재하나 객체 생성 불가
- 호스트 이름과 호스트에 대응하는 IP주소를 알 수 있는 메소드를 제공한다


v 객체를 반환하는 메소드(키워드가 모두 static 임)
- getAllByName(String host) : 매개변수 host에 대응되는 InetAddress 클래스 배열을 반환함
- getAddress(byte[] addr) : 매개변수 addr에 대응되는 InetAddress 클래스 객체를 반환함
- getByAddress(String host, byte[] addr) : 매개변수 host, addr로 생성한 InetAddress 클래스 객체를 반환함

- getByName(String host) : 매개변수 host에 대응되는 InetAddress 클래스 객체를 반환함
- getLocalHost() : 로컬호스트의 InetAddress 클래스 객체를 반환함

** Localhost(로컬호스트)는 서버의 기능을 제공하는 자신의 컴퓨터를 의미한다.
** IPv4에서의 IP주소는 127.0.0.1이다. (32비트 표현) 
(ip = 127.0.0.1 = 로컬호스트 => 나의 피씨를 인터넷에서 나만 볼 수 있는 주소이고 외부접근불가)
** IPv6은 32비트의 ipv4의 값의 표현이 제한적이라 보완되어 나온 물리적 주소 표기방법임. (128비트)


v 메소드
- getAddress() : InetAddress 클래스 객체의 실제 ip주소를 바이트 배열로 반환
- getHostAddress() : ip주소를 문자열로 반환
- getHostName() : 호스트 이름을 문자열로 반환
- toString() : ip주소를 String으로 오버라이딩한 메소드. "호스트이름/ip주소" 형식으로 값을 반환함.

내컴퓨터 ip => cmd >> ipconfig(간단히) / ipconfig /All(자세히)



<데이터베이스>

RDB(Relational DataBase) : 관계형데이타베이스
표구조의 데이터를 테이블이라는 구조화된 형식으로 저장, 변경, 삭제, 추가, 검색등을 지원하는 저장소

RDBMS(Relational DataBase Management System) : 
테이블 구조로 데이터를 저장하고, 변경하고, 삭제하고, 추가, 검색할 수 있는 그 이외에 데이터를 전반적으로 쉽게 관리할 수 있는 시스템을 말함.
종류 : Oracle, MySQL, MariaDB...
데이터는 무조건 테이블 구조로 저장이 된다. (다 테이블화 해버림)
영구적으로 데이터가 반영이 된다. (저장이된다) => 실질적으로 데이터는 파일로 저장이 된다.



<DBMS(데이터베이스 관리 시스템)의 장단점>
1. 장점
⇒ 데이터 중복의 최소화
파일 시스템에서는 각 응용 프로그램마다 자신의 파일이 개별적으로 관리 유지되기 때문에 전체적으로 저장되는 데이터의 입장에서 보면 상당히 많은 데이터가 같은 내용을 표현하면서 중복적으로 저장되고 있다. 그러나, 데이터베이스는 데이터를 통합하여 구성함으로써 이러한 중복을 사전에 통제할 수 있다. 이것은 물론 데이터의 중복을 완전히 배제한다는 것을 의미하는 것은 아니다. 왜냐하면 통합 데이터베이스 환경속에서도 성능 향상의 이유로 데이터의 중복이 불가피할 때가 있기 때문이다.

⇒ 데이터의 공용
같은 내용의 데이터를 여러 가지 구조로 지원해 줄 수 있는 DBMS의 복잡하고도 정교한 기법 때문에 데이터베이스의 데이터 공용이 가능하다. 이것은 기존 여러 응용 프로그램들이 수행하던 데이터에 대한 유지 관리 부담을 면제시켜 줄뿐만 아니라 새로 개발하는 응용 프로그램에 대해서도 데이터 구성에 신경 쓸 필요없이 응용 자체에만 전념할 수 있게 해준다는 것을 의미한다.

⇒ 데이터의 일관성 유지
현실 세계의 어느 한 사실을 나타내는 두 개의 데이터가 있을 때 오직 하나의 데이터만이 변경되고 다른 하나는 변경되지 않는다면 데이터간의 불일치성, 즉 모순성을 갖게 된다. 모순성을 내포한 데이터베이스는 서로 상충되는 정보를 제공하게 되고 데이터베이스의 유용성을 저해하게 된다. 데이터베이스는 관리 시스템은 바로 이 데이터의 중복을 제어하고 중앙 집중식 통제를 통해 데이터의 일관성을 유지할 수 있다.

⇒ 데이터의 무결성 유지
데이터 중복성이 완전히 제거된다고 하더라도 허용되지 않는 값이나 부정확한 데이터가 여러 가지 경로에 의해 데이터베이스에 잠입될 수 도 있다. 데이터베이스 관리 시스템은 데이터베이스가 생성/조작될 때마다 제어 기능(제약조건)을 통해 그 유효성을 검사함으로써 데이터의 무결성을 유지할 수 있다.
(NOT NULL, PRIMARY KEY, FOREIGN KEY등)

⇒ 데이터의 보안 보장
DBMS는 데이터베이스를 중앙 집중식으로 총괄, 관장함으로써 데이터베이스의 관리 및 접근을 효율적으로 통제할 수 있다. 이것은 DBMS가 정당한 사용자, 허용된 데이터와 연산등을 확인 검사함으로써 모든 데이터에 대해 철저한 보안을 제공한다.
일반적으로 같은 내용의 데이터가 여러 파일에 분산 관리될 때 같은 수준의 보장되기는 상당히 어렵다.

⇒ 표준화
DBMS의 중앙 통제 기능을 통해 데이터의 기술양식, 내용, 처리방식, 문서화 양식등에 관한 표준화를 범기관적으로 시행할 수 있다.

⇒ 전체 데이터 요구의 조정
한 기관의 모든 응용 시스템들이 요구하는 데이터들을 전체적으로 수집 분석하고 상충되는 데이터 요구는 조정해서 기관 전체에 가장 유익한 구조로 조직하여 효율적인 정보처리 효과를 얻게 할 수 있다.

2. 단점
⇒ 운영비의 증대
DBMS는 가격으로 보아 고가의 제품이고 컴퓨터 시스템의 지원을 많이 사용한다. 특히, 주기억장치를 많이 차지하기 때문에 DBMS를 운영하기 위해서는 메모리 용량이 더 필요하게 되고, 더 빠른 CPU를 요구하게 된다. 결과적으로 시스템 운영비의 오버헤드를 가중시키게 된다.

⇒ 자료 처리의 복잡화(DB데이타의 처리방법이 복잡해져 전문화된 프로그래머가 필요.)
데이터 베이스에는 상이한 여러 타입의 데이터가 서로 관련되어 있다. 응용 프로그램은 이러한 상황속에서 여러 가지 제한점을 가지고 작성되고 수행될지도 모른다. 다라서, 응용 시스템은 설계 시간이 길어지게 되고 보다 전문적, 기술적이 되어야 하기 때문에 고급 프로그래머가 필요하게 된다.

⇒ 복잡한 예비와 회복
데이터베이스는 그 구조가 복잡하고 여러 사용자가 동시에 공용하기 때문에 문제가 일어났을 때 정확한 이유나 상태를 파악하기 어려울 뿐만 아니라 여기에 대한 예비(Backup, 백업)조치나 사후회복 (Recovery, 복구)기법을 수립해 놓는 것도 매우 어렵다.

⇒ 시스템의 취약성
데이터베이스 시스템은 통합된 시스템이기 때문에 그 일부의 고장이 전체 시스템을 정지시켜 시스템 신뢰성과 가용성을 저해할 수 있다. 이것은 특히 데이터베이스에 의존도가 높은 환경에서는 아주 치명적인 약점이 아닐 수 없다.



<SQL(Structure Query Language)> : 구조화된 명령 언어

직접적으로 데이터를 관리하는데 사용하는 명령문


*SQL 문장
- 명령문은 대/소문자를 구별하지 않는다.
- 하지만 값은 대/소문자를 구분한다.
- SQL 문장은 한 줄 또는 여러 줄에 나눠서 입력할 수 있다.
- SQL 문장의 끝은 반드시 세미콜론(;)으로 끝을 맺는다.


**DML(Data Manipulation Language) 얘빼고 나머진 데이터 이상을 
: 데이터를 조작하는 명령어 = 데이터 조작어
: 데이터를 삽입, 삭제, 변경, 검색(조회)
insert 삽입 => 데이터 추가 기능 명령어
delete 삭제 => 데이터 삭제 기능 명령어 (데이터의 일부제거, 전체제거 가능)
update 변경 => 데이터 갱신(수정) 기능 명령어
select 검색 => 원본은 유지되지만 데이터를 검색해서 가져올 때 변형을 해서 가져올 수 있다. (검색, 조회)
*****반드시 영구적인 반영을 위해서는 TCL(확정 : commit, 되돌리기 : rollback)을 이용해야만 영구반영이 이루어진다.


DQL(Data Query Language) : 데이터를 가져오는 명령만 처리하는 명령문 = 데이터 질의어
select문


DDL(Data Defination Language) : 데이터를 저장하는 구조를 정의, 수정, 제거하는 기능을 처리하는 명령어 = 데이터 정의어
create문 : 테이블, 계정, 뷰, 프로시저, ...등을 생성할 때 사용하는 명령어
alter : 테이블, 계정, 뷰, 프로시저, ...등을 수정, 변경할 때 사용하는 명령어 (이름 변경까지 포함)
drop : 테이블, 계정, 뷰, 프로시저, ...등을 제거할 때 사용하는 명령어
truncate : 테이블의 구조만 제외하고 나머지 데이터를 모두 제거하는 명령어 (내가 지정한 테이블의 모든 데이터를 다 지우는 기능만 있다. 전체 삭제기능. 자동확정됨)


DCL(Data Control Language) : 데이터를 제어하는 기능을 담당하는 명령어 = 데이터 제어어
grant : 계정에 권한을 부여하는 명령
revoke : 계정의 권한을 회수하는 명령


TCL(Transaction Control Language) : 트랜젝션(작업)을 제어하는 명령어 = 트랜젝션 제어어
commit : 데이터베이스에 전체 데이터의 갱신결과를 영구적으로 확정하는 기능
rollback : 데이터베이스에 전체 데이터의 갱신 결과를 영구적으로 전체 되돌리는 기능
checkpoint(savepoint명령) : rollback하는 곳의 시점을 지정하여 전체 rollback이 아닌 원하는 지점까지의 rollback기능을 제공하는 명령어




//22
//필기



<오라클>


- 테이블 명명규칙
-------------------------------------------------------
테이블명은 문자로 시작해야 한다(한글포함)
테이블명은 128Byte이하 작성가능
테이블명은 문자(한글포함), 숫자, 특수문자($,_,#)까지만 사용가능
SQL키워드는 테이블명으로 사용불가
테이블 이름은 대소문자를 가지지 않는다
(단, 큰따옴표로 묶어 처리하는 경우 대소문자 가림)
동일한 계정내에서는 동일한 이름의 객체가 존재하는 경우 테이블명으로 사용할 수 없다 (테이블, 뷰, 함수, 프로시저, 등)
-권장
되도록 테이블명이나 컬럼명은 영어로 기재할 것
되도록 대소문자를 가리지 않도록 명명해줄 것.



- 컬럼(속성) 명명규칙
-------------------------------------------------------
컬럼명은 문자로 시작해야한다.(한글포함)
컬럼명은 문자(한글포함), 숫자, 특수문자($,_,#)까지만 사용가능하다.
SQL키워드는 컬럼명으로 사용할 수 없다.
한 테이블 내에서 동일한 이름으로 지정할 수 없다.




**큰따옴표를 묶어 지정하는 경우는 테이블명 컬럼명 모두 큰따옴표로 묶어야하며, DML, DDL, DCL, 등을 처리할 때도 반드시 큰따옴표로 묶어서 기술해야한다.
-------------------------------------------------------






1. 사용자(user) 계정 생성(create)
[CREATE문 : DDL]
형식 : CREATE USER 사용자계정명 IDENTIFIED BY 비밀번호;
>>예시 : CREATE USER TEST IDENTIFIED BY 1111;

2. 사용자 계정에 권한 부여
[GRANT문 : DCL]
형식 : GRANT 부여할권한1, 부여할권한2, .... TO 사용자계정명;
>>예시 : GRANT CONNECT, RESOURCE, DBA TO TEST;

3. 사용자 계정으로 접근하기(접속하기)
[CONNECT(CONN)문 : 종료세미콜론이 필요없는 문]
형식 : [CONNECT 사용자계정명/비밀번호] 또는 [CONN 사용자계정명/비밀번호]
>>예시 : CONNECT TEST/1111 또는 CONN TEST/1111

4. 테이블(table) 생성(create)하기
[CREATE문 : DDL]
형식 : CREATE TABLE 테이블명(
	컬럼명1 자료형 [제약조건1 제약조건2 ... ... ] , (뒤에 이어지는 컬럼이 있다는 , )
	컬럼명2 자료형 [제약조건1 제약조건2 ... ... ] ,
	...
	컬럼명N 자료형 [제약조건1 제약조건2 ... ... ] (마지막엔 , 없이)
);

4-1. 테이블 생성하기 (테이블 복제본만들기)
**테이블을 만드는 계정과 복제본을 끌어올 계정이 다른 경우는 복제본 테이블의 사용자계정명(스키마명)을 반드시 기술해주어야 한다.
형식 : CREATE TABLE 테이블명 AS SELECT * FROM [사용자계정명(복제할테이블이 속한)-스키마명].복제할테이블명;
**SCOTT계정에서 제공되는 테이블명 : EMP(사원관리 테이블), DEPT(부서관리 테이블), GRADE(등급관리 테이블)
-현재 접속 계정 : TEST인 경우
>>예시 : CREATE TABLE EMP AS SELECT * FROM SCOTT.EMP;
-------------------------------------------------------

**해당 계정내의 전체 테이블 목록 확인하는 명령 : SELECT * FROM TAB;
**해당 테이블의 전체 구조를 확인하는 명령 : DESC 테이블명;	[DESCRIBE]
**SQL PLUS : 오라클에서 무료(오픈소스)로 제공되는 COMMAND LINE INTERFACE 데이터베이스 개발툴

-------------------------------------------------------


* SQL 문법
- 대/소문자를 구별하지 않는다. 하지만 값은 대/소문자를 구분한다.
- SQL 문장은 한 줄 또는 여러 줄에 나눠서 입력할 수 있다.
- SQL 문장의 끝은 반드시 세미콜론(;)으로 끝을 맺는다.


* SELECT문
- DATABASE에 저장되어 있는 자원들을 검색할 때 사용하는 문장이다.
- 구성(문법 : 형식 : Syntax)

	SELECT [DISTINCT(중복값제외하는 키워드)] {*, 컬럼명1, 컬럼명2, ...}
	FROM 테이블명
	WHERE 조건;

- 모든 컬럼을 선택할 때는 "*" 를 사용한다.
하지만 "*"는 컬럼 검색과 함께 연산이 많아서 데이터베이스의 속도를 저하시킨다.





SELECT * | 컬럼명1, 컬럼명2 => 가져올 컬럼을 지정하는 절 : *(아스테리스크) => 전체 컬럼을 다 가져오세요.
FROM 테이블명 => 가져올 데이터가 존재하는 테이블명을 지정하는 절
--ㄴ필수-----------------조건ㄱ------
[WHERE  => 가져올 행 수의 조건을 지정하는 절
GROUP BY => 조건으로 가져온 것 중에서 동일한 값을 가진 컬럼이 있을 경우 그 값의 중복을 제거하는 절
HAVING => 위 GROUP BY절 조건에서 다시 조건을 거는 경우 (반드시 GROUP BY절이 존재해야 사용가능)
ORDER BY => 컬럼의 오름차순(ASC-생략가능,디폴트값), 내림차순(DESC) 지정하는 절]


-- : 오라클의 한 줄 주석 기호
/**/ : 오라클의 여러 줄 주석 기호

>>예시1)
SELECT NO, NM FROM USERLIST
WHERE NO = 2;

>>예시2)
SELECT * 
FROM USERLIST
(오라클한줄주석=>)--WHERE GENDER = '남';
WHERE NO = 1 OR NO = 2 OR NO = 6;
(WHERE NO = 1 AND NO = 2 AND NO = 6;) => 안됨 -표설명

>>예시3)
SELECT NM
FROM USERLIST
GROUP BY NM;

SELECT NM, GENDER
FROM USERLIST
GROUP BY NM, GENDER;
 = 그룹바이를 쓸때 그룹바이에 쓰는 컬럼만 셀렉트해야함

>>예시4)
SELECT NM, GENDER
FROM USERLIST
GROUP BY NM, GENDER
ORDER BY NM(오름차순으로 하고), GENDER DESC; (내림차순으로 마무리)



- 기본틀
SELECT 컬럼
FROM 테이블
[WHERE 조건]

--dept테이블에서 지역이 보스톤인 데이터의 부서명을 가져오세요
SELECT DNAME
FROM DEPT 
WHERE LOC = 'BOSTON';




EMP테이블 : 사원정보 테이블

컬럼명		자료형	코멘트
EMPNO		숫자형	사원번호
ENAME		문자형	사원명
JOB		문자형	직책
MGR		숫자형	상위관리자번호
HIREDATE	날짜형	입사일자
SAL		숫자형	연봉
COMM		숫자형	커미션
DEPTNO		숫자형	부서번호



DEPT테이블 : 부서정보 테이블

컬럼명		자료형	코멘트
DEPTNO		숫자형	부서번호
DNAME		문자형	부서명
LOC		문자형	지역(지점)


SELECT EMPNO, ENAME, DEPTNO
FROM EMP
WHERE ENAME = 'SMITH';

SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP
WHERE DEPTNO = 20;

사원정보 테이블에서 이름과 연봉과 입사일자를 가져와
SELECT 이름과 연봉과 입사일자
FROM 사원정보 테이블

입사일자가 81년 5월 1일 미만인 사원의 사번, 이름을 가져오세요
SELECT EMPNO, ENAME
FROM EMP
WHERE HIREDATE < '1981/05/01';

연봉이 3000이상인 사원의 모든 정보를 가져오시오
SELECT * 
FROM EMP
WHERE SAL >= 3000;




연산자 : 

우선순위 연산자 : ( )
산술연산자 : +(덧셈), -(뺄셈), *(곱셈), /(나눗셈 몫)
비교연산자 : > , >= , < , <= , = 
논리연산자 : AND (모든 조건이 참인 경우만 참, 나머지는 거짓)
	    OR (모든 조건이 거짓인 경우만 거짓, 나머지는 참)
	예시) DEPTNO >= 20 AND DEPTNO <=30   --->   DEPTNO BERWEEN 20 AND 30
DATE자료형(날짜자료형)




//
//23
//필기
//

- SELECT문

SELECT * | 컬럼명들
FROM 테이블명 
WHERE  조건들
GROUP BY 그룹으로 묶을(묶어야 할) 컬럼들
HAVING 그룹으로 묶은 다음 다시 조건을 거는 경우
ORDER BY 컬럼의 오름차순(ASC-생략가능,디폴트값), 내림차순(DESC) 지정하는 절

- 해석순서
FROM절 -> WHERE절 -> GROUP BY절 -> HAVING절 -> SELECT절 -> ORDER BY절


//연습

DEPT 부서번호 부서명
SELECT DEPTNO, DNAME
FROM DEPT;

10번 부서에 해당하는 사원의 이름 급여 입사일자만 가져오는데
이름은 

SELECT ENAME, SAL, HIREDATE
FROM EMP
WHERE DEPTNO = 10;


SELECT절에서 중복값 제외하는 방법
SELECT DISTINCT DEPTNO, JOB FROM EMP;



- 비교 연산자
<, >, <=, >=
같다 =
다르다 <>, !=, ^=

- 논리 연산자
NOT, AND, OR

- SQL 연산자
BETWEEN 값1 AND 값2, IN (값1, 값2, 값3), LIKE , IS NULL, IS NOT NULL

형식 : 컬럼명 BETWEEN 값1 AND 값2 => 값1~값2 사이
형식 : 컬럼명 IN (값1, 값2, 값3) => 값1,2,3 이 포함되는
형식 : 컬럼명 LIKE '문자열값'
형식 : 컬럼명 IS NULL => NULL값에 해당되는 값이 있는지 확인하는 연산자
형식 : 컬럼명 IS NOT NULL => NULL값에 해당되지 않는 값이 있는지 확인하는 연산자
**오라클에서 NULL의 의미 : 어떤 값이 있는지 모른다, 비어있는 값, 빈 문자열


조건절들은 BOOLEAN값을 가져옴

//연습
10번 부서에서 CLERK직책인 사원의 사번, 이름, 직책, 부서번호
SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP
WHERE BETWEEN DEPTNO = 10 AND JOB = 'CLERK';



LIKE : 문자열 일부 포함여부
와일드카드 : 
% => 무슨 문자열이든 상관이 없다. = 어떤 문자열이든 올 수 있다, 몇 개가 오든 상관없다, 아무것도 오지 않아도 상관없다.
_ => 건너띄는 칸 수가 됨. = 문자 한개를 의미, 어떠한 문자가 오든 한 개

형식 : 컬럼명 LIKE '%값'; => 컬럼의 문자열에 앞에는 어떠한 문자든 올 수 있지만 마지막 문자열이 입력한 값으로 끝나는 문자를 가져옴
예) ENAME LIKE '%N' => 이름이 N으로 끝나는 정보를 가져옴
예) ENAME LIKE '%N%' => 이름 안에 N이라는 문자가 포함되는 정보 모두 가져온다.
예) ENAME LIKE 'N%' => 이름이 N으로 시작하는 정보를 가져옴
예) ENAME LIKE '_N%' => 앞 첫글자에 어떠한 문자가 오든 상관없이 단 한 개의 문자가 와야하고, 두번째 문자가 N이라는 문자가 포함되는 정보를 가져옴
예) ENAME LIKE '%N__(2)' => 앞 글자가 어떠한 문자가 몇 개 오든 상관없이 끝에서 세번째 문자가 N으로 끝나는 정보를 가져옴


- AND 연산자
true AND true : true
true AND false : false
true AND null : null
false AND false : false

false AND null : false
null AND null : null


- OR 연산자
true OR true : true
true OR false : true
true OR null : true
false OR false : false

false OR null : null
null OR null : null



* GROUP BY 형식
SELECT GROUP BY에서 설정한 컬럼들, 또는 그룹함수들
FROM 테이블명
WHERE 조건(어떤 컬럼이던 가능)
GROUP BY 그룹으로 묶을 컬럼명들
HAVING 그룹함수로 지정하는 조건 또는 GROUP BY에 설정한 컬럼으로 만드는 조건만 가능
ORDER BY 컬럼의 정렬을 지정;


* 그룹 함수

- 테이블 내의 행들에 대해서 연산한 후 단 하나의 결과 값으로 되돌리는 함수
- WHERE절에는 사용할 수 없다
- SELECT절, HAVING절 에 사용가능
- 반드시 GROUP BY를 해야만 컬럼과 함께 사용할 수 있다.
- GROUP BY가 없는 경우는 SELECT절에 그룹함수만 사용가능
- 종류 : 
합계 : SUM(컬럼명),
평균 : AVG(컬럼명),
최대값 : MAX(컬럼명),
최소값 : MIN(컬럼명),
행(줄) 수 : COUNT(컬럼명 또는 *) 등이 있음
- 그룹 함수는 NULL값을 제외한다. (COUNT(*)만 포함)


NVL함수 : NULL값을 다른 값으로 대체할 때 사용하는 함수
형식 : NVL(컬럼명, 대체할 값)



//연습
사원정보 부서별로 인원수
SELECT DEPTNO, COUNT(*)
FROM EMP
GROUP BY DEPTNO;

부서별로 연봉의 평균이 2000이상인 부서별, 연봉 평균 자료 가져와
SELECT
FROM EMP
GROUP BY DEPTNO, 
HAVING 





**DML(Data Manipulation Language) 얘빼고 나머진 데이터 이상을 
: 데이터를 조작하는 명령어 = 데이터 조작어
: 데이터를 삽입, 삭제, 변경, 검색(조회)
insert 삽입 => 데이터 추가 기능 명령어
delete 삭제 => 데이터 삭제 기능 명령어 (데이터의 일부제거, 전체제거 가능)
update 변경 => 데이터 갱신(수정) 기능 명령어
select 검색 => 원본은 유지되지만 데이터를 검색해서 가져올 때 변형을 해서 가져올 수 있다. (검색, 조회)
*****반드시 영구적인 반영을 위해서는 TCL(확정 : commit, 되돌리기 : rollback)을 이용해야만 영구반영이 이루어진다.




* INSERT명령문 : DML중에서 데이터의 행 수를 추가할 때 사용하는 명령문

--정식형식 : 테이블의 컬럼을 모두 지정하거나 일부만 지정할 때 사용가능 
(없는 값은 NILL값으로 자동처리/ 단, 지정한 기본값이 있는 경우는 해당 지정값으로 자동처리)

INSERT INTO 테이블명 (컬럼명1, 컬럼명2, ...)
VALUES (값1, 값2, ...);

예시) : DEPT01 =>
INSERT INTO DEPT01 (DEPTNO, DNAME, LOC)
VALUES (10, '운영');	//정식형식은 모든 컬럼을 다 채워주지 않아도 된다 (= 원하는 컬럼만 채워도 된다)
또는
INSERT INTO DEPT01 (LOC, DNAME, DEPTNO)
VALUES ('서울', '운영', 10);	//정식형식은 컬럼의 순서도 내맘대로 넣을수 있음

--단축형식 : 

INSERT INRO 테이블명 VALUES (값1, 값2, ...);
**조건 : 반드시 테이블에 있는 컬럼의 개수만큼 컬럼의 순서대로 모두 값(해당 자료형값)을 넣어야 한다.(컬럼명을 쓰지 않기 때문에 맞춰서 넣어야 하는거임)

예시) : DEPT01 => //컬럼의 순서 : (DEPTNO, DNAME, LOC)
INSERT INTO DEPT01 VALUES (10, '운영', '서울');

INSERT INTO DEPT01 VALUES (10, '운영'); (X-불가능)
INSERT INTO DEPT01 VALUES ('서울', '운영', 10); (X-불가능)



* UPDATE명령문 : 데이터를 부분 수정할 때 필요한 명령문 (줄 단위로 처리됨)

형식 : 

UPDATE 테이블명
SET 변경할 컬럼명 = 변경할 값1, 변경할 컬럼명 = 값2, ...
WHERE 조건들...
예시) : DEPT01 => 30번 부서인 부서명을 'CLERK'로 변경해라
UPDATE DEPT01
SET DNAME = 'CLERK'
WHERE DEPTNO = 30;



슈도컬럼(PSEDU) : 처음에는 값이 정해져있지 않으나 실행이 될때 값이 정해지는 컬럼(의사가 존재하는 컬럼)
- SYSDATE : 현재 날짜의 정보를 가지고 있는 예약어(연산자컬럼)




DELETE명령문 : 데이터를 줄(행) 단위로 삭제하는 경우 처리하는 명령문

형식 : 

DELETE 
FROM 테이블명 
WHERE 조건들...;

//연습
사원정보(EMP01)테이블에서 부서번호가 10인 사원만 제거
DELETE FROM EMP01 WHERE DEPTNO = 10;




























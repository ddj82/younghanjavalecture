CREATE OR REPLACE PROCEDURE MY_PARAMETER_TEST_PROC (
P_VAR1 VARCHAR2,
P_VAR2 OUT VARCHAR2,
P_VAR3 IN OUT VARCHAR2) IS
BEGIN
DBMS_OUTPUT.PUT_LINE('P_VAR1 VALUES = ' || P_VAR1);
DBMS_OUTPUT.PUT_LINE('P_VAR2 VALUES = ' || P_VAR2);
DBMS_OUTPUT.PUT_LINE('P_VAR3 VALUES = ' || P_VAR3);
DBMS_OUTPUT.PUT_LINE('');
P_VAR2 := 'B2';
P_VAR3 := 'C2';
DBMS_OUTPUT.PUT_LINE('P_VAR1 VALUES = ' || P_VAR1);
DBMS_OUTPUT.PUT_LINE('P_VAR2 VALUES = ' || P_VAR2);
DBMS_OUTPUT.PUT_LINE('P_VAR3 VALUES = ' || P_VAR3);
DBMS_OUTPUT.PUT_LINE('');
END;
/
-------------------------------------------------------------------------

DECLARE
V_VAR1 VARCHAR2(10) := 'A';
V_VAR2 VARCHAR2(10) := 'B';
V_VAR3 VARCHAR2(10) := 'C';
BEGIN
DBMS_OUTPUT.PUT_LINE('V_VAR1 VALUES = ' || V_VAR1); 
DBMS_OUTPUT.PUT_LINE('V_VAR2 VALUES = ' || V_VAR2); 
DBMS_OUTPUT.PUT_LINE('V_VAR3 VALUES = ' || V_VAR3); 
DBMS_OUTPUT.PUT_LINE('');
MY_PARAMETER_TEST_PROC(V_VAR1, V_VAR2, V_VAR3);
DBMS_OUTPUT.PUT_LINE('V_VAR1 VALUES = ' || V_VAR1);
DBMS_OUTPUT.PUT_LINE('V_VAR2 VALUES = ' || V_VAR2);
DBMS_OUTPUT.PUT_LINE('V_VAR3 VALUES = ' || V_VAR3);
DBMS_OUTPUT.PUT_LINE('');
END;
/
-------------------------------------------------------------------------

--함수에서는 일정한 연산을 수행하고 결과 값을 반환하는 역할을 했지만,
--프로시저에서는 RETURN문을 만나면 이후 로직을 수행하지 않고 프로시저를 빠져나간다.
CREATE OR REPLACE PROCEDURE MY_NEW_JOB_PROC (
P_JOB_ID JOBS.JOB_ID%TYPE,
P_JOB_TITLE JOBS.JOB_TITLE%TYPE,
P_MIN_SAL JOBS.MIN_SALARY%TYPE := 10,
P_MAX_SAL JOBS.MAX_SALARY%TYPE := 100) IS
VN_CNT NUMBER := 0;
BEGIN
IF P_MIN_SAL < 1000 THEN
DBMS_OUTPUT.PUT_LINE('최소 급여값은 1000 이상이어야 한다.');
RETURN; --실행문 완전 종료
END IF;
SELECT COUNT(*) INTO VN_CNT FROM JOBS WHERE JOBS_ID = P_JOB_ID;
IF VN_CNT > 0 THEN
UPDATE JOBS SET
JOB_TITLE = P_JOB_TITLE,
MIN_SALARY = P_MIN_SAL,
MAX_SALARY = P_MAX_SAL,
UPDATE_DATE = SYSDATE
WHERE JOB_ID = P_JOB_ID;
DBMS_OUTPUT.PUT_LINE('데이터 갱신완료');
ELSE 
INSERT INTO JOBS (JOB_ID, JOB_TITLE, MIN_SALARY, MAX_SALARY, CREATE_DATE, UPDATE_DATE)
VALUES (P_JOB_ID, P_JOB_TITLE, P_MIN_SAL, P_MAX_SAL, SYSDATE, SYSDATE);
DBMS_OUTPUT.PUT_LINE('데이터 추가완료');
END IF;
COMMIT;
END;
/
-------------------------------------------------------------------------

EXEC MY_NEW_JOB_PROC('SM_JOB1', 'SAMPLE JOB1', 999, 6000);
EXEC MY_NEW_JOB_PROC('SM_JOB1', 'SAMPLE JOB1', 2000, 6000);
-------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE DEPT_INSERT_PROC (
P_TNM VARCHAR2,
P_DNO DEPT.DEPTNO%TYPE,
P_NM DEPT.DNAME%TYPE,
P_LOC DEPT.LOC%TYPE)
IS
V_CNT NUMBER;
V_SQL VARCHAR2(1000);
BEGIN
DBMS_OUTPUT.PUT_LINE('프로시저 시작');
V_SQL := 'SELECT COUNT(*) FROM ' || P_TNM || ' WHERE DEPTNO = :A';
EXECUTE IMMEDIATE V_SQL INTO V_CNT USING P_DNO;
IF V_CNT <= 0 THEN
V_SQL := 'INSERT INTO ' || P_TNM || ' VALUES (:A, :A, :A)';
EXECUTE IMMEDIATE V_SQL USING P_DNO, P_NM, P_LOC;
DBMS_OUTPUT.PUT_LINE('인서트 성공');
ELSE
V_SQL := 'UPDATE ' || P_TNM || ' SET DNAME = :A, LOC = :A WHERE DEPTNO = :A';
EXECUTE IMMEDIATE V_SQL USING P_NM, P_LOC, P_DNO;
DBMS_OUTPUT.PUT_LINE('업데이트 성공');
END IF;
COMMIT;
DBMS_OUTPUT.PUT_LINE('프로시저 종료');
END;
/
-------------------------------------------------------------------------

DECLARE
V_CNT NUMBER;
V_SQL VARCHAR2(1000);
BEGIN
SELECT COUNT(*) INTO V_CNT FROM ALL_TABLES WHERE TABLE_NAME = 'DEPT01';
--SELECT COUNT(*) INTO V_CNT FROM TAB WHERE TNAME = 'DEPT01';
IF V_CNT <= 0 THEN
V_SQL := 'CREATE TABLE DEPT01 AS SELECT * FROM DEPT';
EXECUTE IMMEDIATE V_SQL;
DBMS_OUTPUT.PUT_LINE('테이블 생성 성공');
END IF;
SELECT COUNT(*) INTO V_CNT FROM ALL_TABLES WHERE TABLE_NAME = 'DEPT01';
--SELECT COUNT(*) INTO V_CNT FROM TAB WHERE TNAME = 'DEPT01';
IF V_CNT > 0 THEN
DEPT_INSERT_PROC('DEPT01', 50, 'TEST', 'TEST');
DBMS_OUTPUT.PUT_LINE('프로시저 호출 성공');
END IF;
END;
/
-------------------------------------------------------------------------

--테이블 백업용 프로시저
CREATE OR REPLACE PROCEDURE DEPT_INSERT_PROC(P_TNM VARCHAR2)
IS
V_CNT NUMBER;
V_SQL VARCHAR2(1000);
V_TNM VARCHAR2(200) := P_TNM || '_' || TO_CHAR(SYSDATE, 'YYYYMMDD');
BEGIN
DBMS_OUTPUT.PUT_LINE(P_TNM || ' 테이블 백업 시작');
DBMS_OUTPUT.PUT_LINE('백업 테이블명 : ' || V_TNM);
SELECT COUNT(*) INTO V_CNT FROM TAB WHERE TNAME = V_TNM;

IF V_CNT <= 0 THEN
V_SQL := 'CREATE TABLE ' || V_TNM || ' AS SELECT * FROM ' || P_TNM;
EXECUTE IMMEDIATE V_SQL;
DBMS_OUTPUT.PUT_LINE('테이블 생성 성공');

ELSE 
V_SQL := 'DROP TABLE ' || V_TNM;
EXECUTE IMMEDIATE V_SQL;
DBMS_OUTPUT.PUT_LINE('기존 테이블 삭제 성공');

V_SQL := 'CREATE TABLE ' || V_TNM || ' AS SELECT * FROM ' || P_TNM;
EXECUTE IMMEDIATE V_SQL;
DBMS_OUTPUT.PUT_LINE('테이블 생성 성공');

END IF;
DBMS_OUTPUT.PUT_LINE('백업 완료');
END;
/
-------------------------------------------------------------------------

EXEC DEPT_INSERT_PROC('DEPT01');

BEGIN
DEPT_INSERT_PROC('EMP');
END;
/
-------------------------------------------------------------------------

--에러발생 예제
DECLARE
VI_NUM NUMBER := 0;
BEGIN
DBMS_OUTPUT.PUT_LINE('시작');
DBMS_OUTPUT.PUT_LINE('VI_NUM = ' || VI_NUM);
VI_NUM := 10 / 0;
DBMS_OUTPUT.PUT_LINE('Success!');
DBMS_OUTPUT.PUT_LINE('VI_NUM = ' || VI_NUM);
EXCEPTION
WHEN OTHERS THEN 
DBMS_OUTPUT.PUT_LINE('에러발생 ' || SQLERRM);
VI_NUM := 10 / 2;
DBMS_OUTPUT.PUT_LINE('정상종료 VI_NUM = ' || VI_NUM);
END;
/
-------------------------------------------------------------------------

DECLARE
VI_NUM NUMBER := 0;
BEGIN
DBMS_OUTPUT.PUT_LINE('시작');
DBMS_OUTPUT.PUT_LINE('VI_NUM = ' || VI_NUM);
VI_NUM := 10 / 0;
DBMS_OUTPUT.PUT_LINE('Success!');
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('오류가 발생했습니다.');
DBMS_OUTPUT.PUT_LINE('VI_NUM = ' || VI_NUM);
BEGIN
SELECT MOD(5, 2) INTO VI_NUM FROM DUAL;
DBMS_OUTPUT.PUT_LINE('VI_NUM = ' || VI_NUM);
END;
END;
/
-------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE EXCEPTION_PROC
IS
VI_NUM NUMBER := 0;
BEGIN
DBMS_OUTPUT.PUT_LINE('시작');
VI_NUM := 10 / 0;
DBMS_OUTPUT.PUT_LINE('Success!');
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('오류가 발생했습니다.');

DBMS_OUTPUT.PUT_LINE('SQL ERROR CODE : ' || SQLCODE);

--매개변수가 없는 SQLERRM
DBMS_OUTPUT.PUT_LINE('SQL ERROR MESSAGE : ' || SQLERRM);

--매개변수가 있는 SQLERRM
DBMS_OUTPUT.PUT_LINE('SQLERRM(SQLCODE) : ' || SQLERRM(SQLCODE));

DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END;
/
-------------------------------------------------------------------------

EXEC EXCEPTION_PROC;

BEGIN
EXCEPTION_PROC;
END;
/
-------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE EXCEPTION_PROC
IS
VI_NUM NUMBER := 0;
BEGIN
DBMS_OUTPUT.PUT_LINE('시작');
VI_NUM := 10 / 0;
DBMS_OUTPUT.PUT_LINE('Success!');
EXCEPTION WHEN ZERO_DIVIDE THEN
DBMS_OUTPUT.PUT_LINE('오류가 발생했습니다.');
DBMS_OUTPUT.PUT_LINE('SQL ERROR CODE : ' || SQLCODE);
DBMS_OUTPUT.PUT_LINE('SQL ERROR MESSAGE : ' || SQLERRM);
END;
/
-------------------------------------------------------------------------

EXEC EXCEPTION_PROC;

BEGIN
EXCEPTION_PROC;
END;
/
-------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE EXCEPTION_PROC
IS
VI_NUM NUMBER := 0;
VEMPNO EMP.EMPNO%TYPE;
VENAME EMP.ENAME%TYPE;
BEGIN
DBMS_OUTPUT.PUT_LINE('시작');
SELECT EMPNO, ENAME INTO VEMPNO, VENAME FROM EMP WHERE DEPTNO = 10;
DBMS_OUTPUT.PUT_LINE('Success!');
EXCEPTION 
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('NO_DATA_FOUND 오류가 발생했습니다.');
DBMS_OUTPUT.PUT_LINE('SQL ERROR CODE : ' || SQLCODE);
DBMS_OUTPUT.PUT_LINE('SQL ERROR MESSAGE : ' || SQLERRM);
WHEN TOO_MANY_ROWS THEN
DBMS_OUTPUT.PUT_LINE('TOO_MANY_ROWS 오류가 발생했습니다.');
DBMS_OUTPUT.PUT_LINE('SQL ERROR CODE : ' || SQLCODE);
DBMS_OUTPUT.PUT_LINE('SQL ERROR MESSAGE : ' || SQLERRM);
END;
/
-------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE EXCEPTION_PROC
IS
VI_NUM NUMBER := 0;
VEMPNO EMP.EMPNO%TYPE;
VENAME EMP.ENAME%TYPE;
BEGIN
DBMS_OUTPUT.PUT_LINE('시작');
SELECT EMPNO, ENAME INTO VEMPNO, VENAME FROM EMP WHERE 1 = 0;
DBMS_OUTPUT.PUT_LINE('Success!');
EXCEPTION 
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('NO_DATA_FOUND 오류가 발생했습니다.');
DBMS_OUTPUT.PUT_LINE('SQL ERROR CODE : ' || SQLCODE);
DBMS_OUTPUT.PUT_LINE('SQL ERROR MESSAGE : ' || SQLERRM);
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('TOO_MANY_ROWS 오류가 발생했습니다.');
DBMS_OUTPUT.PUT_LINE('SQL ERROR CODE : ' || SQLCODE);
DBMS_OUTPUT.PUT_LINE('SQL ERROR MESSAGE : ' || SQLERRM);
END;
/
-------------------------------------------------------------------------

EXEC EXCEPTION_PROC;

BEGIN
EXCEPTION_PROC;
END;
/
-------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE EXCEPTION_PROC
IS
VI_NUM NUMBER := 0;
VEMPNO EMP.EMPNO%TYPE;
VENAME EMP.ENAME%TYPE;
BEGIN
DBMS_OUTPUT.PUT_LINE('시작');
SELECT EMPNO, ENAME INTO VEMPNO, VENAME FROM EMP WHERE DEPTNO = 10;
DBMS_OUTPUT.PUT_LINE('Success!');
EXCEPTION 
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('NO_DATA_FOUND 오류가 발생했습니다.');
DBMS_OUTPUT.PUT_LINE('SQL ERROR CODE : ' || SQLCODE);
DBMS_OUTPUT.PUT_LINE('SQL ERROR MESSAGE : ' || SQLERRM);
WHEN TOO_MANY_ROWS THEN
DBMS_OUTPUT.PUT_LINE('TOO_MANY_ROWS 오류가 발생했습니다.');
DBMS_OUTPUT.PUT_LINE('SQL ERROR CODE : ' || SQLCODE);
DBMS_OUTPUT.PUT_LINE('SQL ERROR MESSAGE : ' || SQLERRM);

BEGIN
DBMS_OUTPUT.PUT_LINE('예외처리 후 구문 시작');
VI_NUM := 10 / 0;
DBMS_OUTPUT.PUT_LINE('BY ZERO에러 발생 후');
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('BY ZERO에러 발생');
END;
DBMS_OUTPUT.PUT_LINE('시스템 정상종료');
END;
/
-------------------------------------------------------------------------

EXEC EXCEPTION_PROC;

BEGIN
EXCEPTION_PROC;
END;
/
-------------------------------------------------------------------------

CREATE TABLE T1(C1 NUMBER);

--BEFORE 트리거
CREATE OR REPLACE TRIGGER TRI_T1
BEFORE INSERT ON T1
BEGIN
DBMS_OUTPUT.PUT_LINE('B');
END;
/

--AFTER 트리거
CREATE OR REPLACE TRIGGER TRI_T2
AFTER INSERT ON T1
BEGIN
DBMS_OUTPUT.PUT_LINE('A');
END;
/

INSERT INTO T1 VALUES (1);
DROP TABLE T1 PURGE;
-------------------------------------------------------------------------

CREATE TABLE T1 AS SELECT 1 AS C1, 1 AS C2 FROM DUAL;

CREATE OR REPLACE TRIGGER TRG_T1_C1
BEFORE UPDATE OF C1 ON T1 --OF C1 ON T1 => T1테이블 안에 C1컬럼 만
BEGIN
DBMS_OUTPUT.PUT_LINE('C1');
END TRG_T1_C1;
/

CREATE OR REPLACE TRIGGER TRG_T1_C2
BEFORE UPDATE OF C2 ON T1 --OF C1 ON T1 => T1테이블 안에 C2컬럼 만
BEGIN
DBMS_OUTPUT.PUT_LINE('C2');
END TRG_T1_C2;
/

UPDATE T1 SET C1 = 2 WHERE C1 = 1;

ROLLBACK;
-------------------------------------------------------------------------

CREATE OR REPLACE TRIGGER TRG_T1_C1
BEFORE UPDATE OF C2 ON T1
BEGIN
DBMS_OUTPUT.PUT_LINE('C1');
END TRG_T1_C1;
/

CREATE OR REPLACE TRIGGER TRG_T1_C2
BEFORE UPDATE OF C2 ON T1
FOLLOWS TRG_T1_C1
BEGIN
DBMS_OUTPUT.PUT_LINE('C2');
END TRG_T1_C2;
/

UPDATE T1 SET C2 = 2 WHERE C1 = 1;

ALTER TRIGGER TRG_T1_C1 DISABLE;
ALTER TRIGGER TRG_T1_C1 ENABLE;

DROP TRIGGER TRG_T1_C1;
DROP TRIGGER TRG_T1_C2;
-------------------------------------------------------------------------

CREATE OR REPLACE TRIGGER TRI_T1
BEFORE INSERT OR UPDATE OR DELETE ON T1
FOR EACH ROW
BEGIN
DBMS_OUTPUT.PUT_LINE(:OLD.C1 || ', ' || :NEW.C1);
END;
/

INSERT INTO T1 VALUES (1);
UPDATE T1 SET C1 = 2;
DELETE T1;
ROLLBACK;
-------------------------------------------------------------------------

CREATE OR REPLACE TRIGGER TRG_DEPT
BEFORE INSERT OR UPDATE OR DELETE ON TEST.DEPT
REFERENCING OLD AS BF NEW AS AF
FOR EACH ROW
BEGIN
DBMS_OUTPUT.PUT_LINE('OLD DEPT : ' || :BF.DEPTNO || ', ' || :BF.DNAME || ', ' || :BF.LOC);
DBMS_OUTPUT.PUT_LINE('NEW DEPT : ' || :AF.DEPTNO || ', ' || :AF.DNAME || ', ' || :AF.LOC);
END;
/

INSERT INTO DEPT VALUES (50, 'ABC', 'ABC');
UPDATE DEPT SET DNAME = 'HAHAHA' WHERE DEPTNO = 50;
DELETE FROM DEPT WHERE DEPTNO = 50;

DROP TRIGGER TRG_DEPT;
-------------------------------------------------------------------------

CREATE PROCEDURE PRO_COMMIT
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('프로시저 실행');
COMMIT;
END;
/
-------------------------------------------------------------------------

CREATE OR REPLACE TRIGGER TRG_T1
BEFORE INSERT ON T1
FOR EACH ROW
WHEN (NEW.C1 >= 3)
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
:NEW.C2 := 0;
DBMS_OUTPUT.PUT_LINE(':NEW.C2의 값 : ' || :NEW.C2);
PRO_COMMIT;
END;
/

CREATE TABLE TI (C1 NUMBER, C2 NUMBER);

INSERT INTO T1 VALUES (5, 2);

ROLLBACK;
-------------------------------------------------------------------------

ALTER TABLE EMP ADD DNAME VARCHAR2(14);

CREATE OR REPLACE PROCEDURE EMP_UD_PROC (
P_DEPTNO DEPT.DEPTNO%TYPE,
P_DNAME DEPT.DNAME%TYPE) IS
BEGIN
UPDATE EMP SET DNAME = P_DNAME WHERE DEPTNO = P_DEPTNO;
DBMS_OUTPUT.PUT_LINE('EMP테이블의 부서명 변경 완료');
END;
/

CREATE OR REPLACE TRIGGER TRG_DEPT
BEFORE INSERT OR UPDATE OR DELETE ON DEPT
REFERENCING OLD AS BF NEW AS AF
FOR EACH ROW
--DECLARE
--PRAGMA AUTONOMOUS_TRANSACTION;
--V_DEPTNO DEPT.DEPTNO%TYPE;
--V_DNAME DEPT.DNAME%TYPE;
BEGIN
DBMS_OUTPUT.PUT_LINE('OLD DEPT : ' || :BF.DEPTNO || ', ' || :BF.DNAME || ', ' || :BF.LOC);
DBMS_OUTPUT.PUT_LINE('NEW DEPT : ' || :AF.DEPTNO || ', ' || :AF.DNAME || ', ' || :AF.LOC);
--DBMS_OUTPUT.PUT_LINE(V_DEPTNO || ' / ' || V_DNAME);
EMP_UD_PROC(:BF.DEPTNO, :AF.DNAME);
END;
/
-------------------------------------------------------------------------

BEGIN
UPDATE DEPT SET DNAME = 'SALESMAN' WHERE DEPTNO = 30;
COMMIT;
END;
/
-------------------------------------------------------------------------


-------------------------------------------------------------------------


-------------------------------------------------------------------------


-------------------------------------------------------------------------


-------------------------------------------------------------------------


-------------------------------------------------------------------------


-------------------------------------------------------------------------


-------------------------------------------------------------------------


-------------------------------------------------------------------------

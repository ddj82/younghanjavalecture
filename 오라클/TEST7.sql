CREATE TABLE EMP01
AS SELECT * FROM EMP;
-------------------------------------------------------------------------

CREATE VIEW VIEW_EMP01
AS
SELECT EMPNO, ENAME, SAL, DEPTNO 
FROM EMP01
WHERE DEPTNO = 10;
-------------------------------------------------------------------------

SELECT * FROM VIEW_EMP01;
-------------------------------------------------------------------------

DROP VIEW VIEW_EMP01;
-------------------------------------------------------------------------

CREATE VIEW VIEW_EMP01
AS 
SELECT EMPNO 사번, ENAME 이름, SAL 연봉, DEPTNO 부서
FROM EMP01
WHERE DEPTNO = 10;
-------------------------------------------------------------------------

SELECT * FROM VIEW_EMP01;
SELECT * FROM VIEW_EMP01 WHERE 사번 = 7782;
-------------------------------------------------------------------------

INSERT INTO VIEW_EMP01 (사번, 부서)  VALUES (7777, 10); --EMP01 테이블에 추가됨
COMMIT;
-------------------------------------------------------------------------

SELECT * FROM VIEW_EMP01;
SELECT * FROM EMP01;

DELETE FROM VIEW_EMP01 WHERE 사번 = 7777;
COMMIT;

DROP VIEW VIEW_EMP01;
-------------------------------------------------------------------------

SELECT * FROM USER_VIEWS;
-------------------------------------------------------------------------

CREATE VIEW VIEW_EMP_DEPT
AS
SELECT ENAME, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;
-------------------------------------------------------------------------

SELECT * FROM VIEW_EMP_DEPT;

SELECT * FROM EMP;

UPDATE EMP SET DEPTNO = 40 WHERE DEPTNO IS NULL;

SELECT * FROM DEPT;

ROLLBACK;
-------------------------------------------------------------------------

--CREATE VIEW VIEW_EMP_DEPT AS 
--SELECT ENAME, DEPT.DEPTNO, DNAME FROM EMP, DEPT 
--WHERE EMP.DEPTNO = DEPT.DEPTNO;
--
--CREATE TABLE VIEW_EMP_DEPT AS SELECT * FROM EMP;
--둘 다 오류
-------------------------------------------------------------------------

CREATE OR REPLACE VIEW VIEW_EMP_DEPT AS
SELECT ENAME, EMP.DEPTNO, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND EMP.DEPTNO = 30;

SELECT * FROM VIEW_EMP_DEPT;

DROP VIEW VIEW_EMP_DEPT;
-------------------------------------------------------------------------

CREATE VIEW VIEW_EMP_DEPT
AS SELECT EMPNO, ENAME, DEPT.DEPTNO, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;

CREATE TABLE EMPDEPT AS
SELECT * FROM VIEW_EMP_DEPT;

DELETE FROM EMPDEPT WHERE EMPNO = 7698;

SELECT * FROM VIEW_EMP_DEPT;
-------------------------------------------------------------------------

CREATE TABLE CUST AS SELECT * FROM CUSTOMERS;

ALTER TABLE CUST
ADD CONSTRAINT CUST_CUST_ID_PK PRIMARY KEY(CUST_ID); --인덱스 자동생성
-------------------------------------------------------------------------

SELECT * FROM CUSTOMERS WHERE CUST_ID = 4141;

SELECT * FROM CUST WHERE CUST_ID = 4141; --인덱스가 있어서 더 빠름
-------------------------------------------------------------------------

ALTER TABLE CUST DROP CONSTRAINT CUST_CUST_ID_PK; --인덱스 자동삭제
-------------------------------------------------------------------------

CREATE INDEX CUST_CUSTID_IDX ON CUST (CUST_ID);
-------------------------------------------------------------------------

ALTER INDEX CUST_CUSTID_IDX RENAME TO CUST_ID_INDEX;
-------------------------------------------------------------------------

DROP INDEX CUST_ID_INDEX;
-------------------------------------------------------------------------

CREATE INDEX CUST_GENDER_IDX ON CUST (CUST_GENDER);

CREATE UNIQUE INDEX CUST_ID_IDX ON CUST (CUST_ID);
CREATE UNIQUE INDEX CUST_CITY_IDX ON CUST (CUST_CITY); --오류

DROP INDEX CUST_GENDER_IDX;
-------------------------------------------------------------------------

SELECT * FROM CUSTOMERS WHERE CUST_ID + 1 > 2; --인덱스 불가

SELECT * FROM CUST WHERE CUST_ID + 1 > 2; --인덱스 불가

SELECT * FROM EMPLOYEES 
WHERE SUBSTR(HIRE_DATR, 1, LENGTH(HIRE_DATR)) = '08/03/08'; --인덱스 불가

SELECT * FROM EMPLOYEES WHERE HIRE_DATR = '08/03/08'; --인덱스 가능

SELECT * FROM EM WHERE HIRE_DATR = '08/03/08'; --인덱스 가능

SELECT * FROM CUSTOMERS WHERE CUST_ID = NVL(CUST_ID, 10); --인덱스 불가

SELECT * FROM CUST WHERE CUST_ID > 10; --인덱스 가능
SELECT * FROM CUST WHERE CUST_ID != 10; --인덱스 가능
SELECT * FROM CUST WHERE CUST_ID ^= 10; --인덱스 가능
SELECT * FROM CUST WHERE CUST_ID <> 10; --인덱스 불가능 (예외사항)
-------------------------------------------------------------------------

ALTER TABLE CUSTOMERS DROP CONSTRAINT CTM_ID_PK;

DROP TABLE CUST PURGE;
CREATE TABLE CUST AS SELECT * FROM CUSTOMERS WHERE ROWNUM <= 454;
CREATE INDEX CUST_ID_IDX ON CUST(CUST_ID);

--INDEX 딕셔너리에 BLEVEL로 레벨 확인 방법
SELECT TABLE_NAME, INDEX_NAME, BLEVEL FROM DBA_INDEXES WHERE OWNER = 'TEST';

DROP TABLE CUST PURGE;
CREATE TABLE CUST AS SELECT * FROM CUSTOMERS WHERE ROWNUM <= 456;
CREATE INDEX CUST_ID_IDX ON CUST(CUST_ID);

--INDEX 딕셔너리에 BLEVEL로 레벨 확인 방법
SELECT TABLE_NAME, INDEX_NAME, BLEVEL FROM DBA_INDEXES WHERE OWNER = 'TEST';

DROP TABLE CUST PURGE;
CREATE TABLE CUST AS SELECT * FROM CUSTOMERS WHERE ROWNUM <= 486;
ALTER TABLE CUST ADD CONSTRAINT CUST_ID_PK PRIMARY KEY (CUST_ID);

--INDEX 딕셔너리에 BLEVEL로 레벨 확인 방법
SELECT TABLE_NAME, INDEX_NAME, BLEVEL FROM DBA_INDEXES WHERE OWNER = 'TEST';

DROP TABLE CUST PURGE;
CREATE TABLE CUST AS SELECT * FROM CUSTOMERS WHERE ROWNUM <= 485;
ALTER TABLE CUST ADD CONSTRAINT CUST_ID_PK PRIMARY KEY (CUST_ID);

--INDEX 딕셔너리에 BLEVEL로 레벨 확인 방법
SELECT TABLE_NAME, INDEX_NAME, BLEVEL FROM DBA_INDEXES WHERE OWNER = 'TEST';

ALTER INDEX CUST_ID_PK REBUILD;
-------------------------------------------------------------------------

--INT자료형 (= NUMBER(38)과 동일) : 음수, 0, 양수만 표현
CREATE TABLE BOARD (
NO INT PRIMARY KEY,
SUBJECT VARCHAR2(30),
CONTENT VARCHAR2(50),
W_DATE DATE
);

CREATE SEQUENCE SEQ_NO NOCACHE;

/* 시퀀스 사용형식
시퀀스명. NEXTVAL         시퀀스명. CURRVAL
*/

INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java1', 'java', SYSDATE); --1
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '자바', SYSDATE); --2
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java3', 수업, SYSDATE); --오류
--자료형의 오류가 발생하면 다음 시퀀스는 가져오지 않는다
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java3', '수업', SYSDATE); --3

SELECT * FROM BOARD;
ROLLBACK;

INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java1', 'java', SYSDATE); --4

DELETE FROM BOARD WHERE NO = 4;

INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '자바', SYSDATE); --5
COMMIT;
SELECT * FROM BOARD;

SELECT SEQ_NO.CURRVAL FROM DUAL;
SELECT SEQ_NO.NEXTVAL FROM DUAL;

DROP TABLE BOARD PURGE;
DROP SEQUENCE SEQ_NO;
-------------------------------------------------------------------------

--INT자료형 (= NUMBER(38)과 동일) : 음수, 0, 양수만 표현
CREATE TABLE BOARD (
NO INT PRIMARY KEY,
SUBJECT VARCHAR2(30),
CONTENT VARCHAR2(50),
W_DATE DATE
);

--시퀀스를 MAX부터 -1씩 감소하게 만들기.
CREATE SEQUENCE SEQ_NO
START WITH 5 -- 이 부분은 생략가능.
INCREMENT BY -1
MAXVALUE 5 -- 이 부분은 생략불가, START값이 MAX보다 크면 안됨
NOCACHE; -- 이 부분은 생략가능. 디폴트가 NOCACHE
--CYCLE인 경우는 반드시 MINVALUE가 존재해야 함.

INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java1', 'java', SYSDATE); --5
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '자바', SYSDATE); --4
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java3', '수업', SYSDATE); --3
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '영어', SYSDATE); --2
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '국어', SYSDATE); --1
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '고어', SYSDATE); --0

INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '수학', SYSDATE); -- -1
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '한문', SYSDATE); -- -2
SELECT * FROM BOARD;

SELECT SEQ_NO.CURRVAL FROM DUAL;
DROP SEQUENCE SEQ_NO;
ROLLBACK;
SELECT * FROM BOARD;
TRUNCATE TABLE BOARD;
-------------------------------------------------------------------------

CREATE SEQUENCE SEQ_NO
--STRAT WIRH 1
INCREMENT BY 2
MAXVALUE 5
--MINVALUE 1
CYCLE CACHE 2;

INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java1', 'java', SYSDATE); --1
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '자바', SYSDATE); --3
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java3', '수업', SYSDATE); --5

ALTER TABLE BOARD DROP CONSTRAINT SYS_C007093;

INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '영어', SYSDATE); --1 (X) PK 오류
--제약조건의 오류가 발생하면 다음 시퀀스를 가져온다
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '영어', SYSDATE); --3

INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '국어', SYSDATE); --5
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '고어', SYSDATE); --1

SELECT * FROM BOARD;
SELECT SEQ_NO.CURRVAL FROM DUAL;

DROP SEQUENCE SEQ_NO;
DROP TABLE BOARD PURGE;
-------------------------------------------------------------------------

CREATE TABLE BOARD (
NO INT PRIMARY KEY,
SUBJECT VARCHAR2(30) NOT NULL,
CONTENT VARCHAR2(50),
W_DATE DATE
);

CREATE SEQUENCE SEQ_NO NOCACHE;

INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java1', 'java', SYSDATE); --1
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '자바', SYSDATE); --2
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java3', '수업', SYSDATE); --3
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '영어', SYSDATE); --4
INSERT INTO BOARD VALUES(SEQ_NO.NEXTVAL, 'java2', '국어', SYSDATE); --5
COMMIT;
SELECT * FROM BOARD;

SELECT SEQ_NO.CURRVAL FROM DUAL;
-------------------------------------------------------------------------

DROP TABLE EMP01 PURGE;

SELECT SEQ_NO.CURRVAL FROM DUAL;

CREATE TABLE EMP01 AS 
SELECT SEQ_NO.NEXTVAL, EMPNO, ENAME, DEPTNO, SAL, JOB FROM EMP; --6부터 뽑는다

ALTER TABLE EMP01 DROP (NEXTVAL);
SELECT * FROM EMP01;

INSERT INTO EMP01 VALUES (SEQ_NO.NEXTVAL, 'MARIA', 90, 6000, 'BABO'); --20

UPDATE EMP01 SET EMPNO = SEQ_NO.NEXTVAL, DEPTNO = SEQ_NO.NEXTVAL 
WHERE EMPNO = 20; --NEXTVAL이 여러 개 있어도 한 명령안에 있으면 똑같은 번호를 부여함
SELECT * FROM EMP01;

DROP TABLE EMP01 PURGE;
DROP TABLE BOARD PURGE;
DROP SEQUENCE SEQ_NO;
-------------------------------------------------------------------------

CREATE SEQUENCE BOA_SEQ
START WITH 1
INCREMENT BY 1
--MINVALUE 1
MAXVALUE 10000
NOCACHE; --시작 값이 1이고 1씩 증가, 최대값이 10000이 되는 시퀀스 BOA_SEQ 생성

CREATE TABLE BOARD (
NO INT PRIMARY KEY,
SUBJECT VARCHAR2(30) NOT NULL,
CONTENT VARCHAR2(50),
W_DATE DATE
);

CREATE TABLE BOA01 AS
SELECT * FROM BOARD WHERE 1=0;

INSERT INTO BOA01 VALUES(BOA_SEQ.NEXTVAL, 'JULIA', 'SEQ', SYSDATE);
-------------------------------------------------------------------------

CREATE TABLE DEPT01 AS SELECT * FROM DEPT WHERE 1=0;

SELECT * FROM DEPT01;

CREATE SEQUENCE DEPT_SEQ
START WITH 10
INCREMENT BY 10
--MINVALUE 1
MAXVALUE 30;

INSERT INTO DEPT01 VALUES (DEPT_SEQ.NEXTVAL, 'ACCOUNTING', 'NEW YORK'); --10
SELECT * FROM DEPT01;

INSERT INTO DEPT01 VALUES (DEPT_SEQ.NEXTVAL, 'RESEARCH', 'DALLAS'); --20
SELECT * FROM DEPT01;

ALTER SEQUENCE DEPT_SEQ
--START WITH는 수정안됨
INCREMENT BY 10
MINVALUE 10
MAXVALUE 100
CYCLE CACHE 9;

INSERT INTO DEPT01 VALUES (DEPT_SEQ.NEXTVAL, 'SALES', 'CHICAGO');
SELECT * FROM DEPT01;

INSERT INTO DEPT01 VALUES (DEPT_SEQ.NEXTVAL, 'PRODUCT', 'TAIWAN');
SELECT * FROM DEPT01;

ALTER TABLE DEPT01 MODIFY DEPTNO NUMBER(4);

DROP TABLE DEPT01 PURGE;
DROP SEQUENCE DEPT_SEQ;
-------------------------------------------------------------------------

CREATE TABLE DEPT01 AS SELECT * FROM DEPT WHERE 1=0;

CREATE SEQUENCE DEPT_SEQ
START WITH 10
INCREMENT BY 10
MINVALUE 10
MAXVALUE 100
CYCLE CACHE 9;

ALTER TABLE DEPT01 MODIFY DEPTNO NUMBER(4);

INSERT INTO DEPT01 VALUES (DEPT_SEQ.NEXTVAL, 'PRODUCT', 'TAIWAN');
SELECT * FROM DEPT01;
-------------------------------------------------------------------------

CREATE TABLE DEPT01 AS
SELECT * FROM DEPT;

ALTER TABLE DEPT01
ADD CONSTRAINT DEPT01_DEPTNO_PK PRIMARY KEY (DEPTNO);

DESC USER_CONSTRAINTS;
SELECT CONSTRAINT_NAME, CONSTRAINT_NAME, TABLE_NAME, OWNER FROM USER_CONSTRAINTS
WHERE OWNER = 'TEST';

ALTER TABLE DEPT01
MODIFY DNAME NOT NULL;


CREATE TABLE DEPT02 AS
SELECT * FROM DEPT01; --PRIMARY KEY는 복제안됨, 제약조건 중 복제 되는건 NOT NULL 뿐

DROP TABLE DEPT02 PURGE;
-------------------------------------------------------------------------

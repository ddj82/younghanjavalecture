http://naver.me/FpZHfhxW




<조건문 형식>

if (조건) {
	실행문들;
}


if () {
	실행문들;
	...;
} else if() {
	실행문들;
	...;
} else {
	실행문들;
	...;
}



switch (케이스값- byte, short, int, char, String) {
case 1: 실행문; 
	break;
case 2: 실행문; 
	break;
case 3: 실행문; 
	break;
default: 실행문;
}



<변수 선언 형식>

//선언만
자료명 변수명;


//선언과 동시에 초기화
자료명 변수명 = 값(리터럴 = Literal);


//자료형이 같은 변수를 동시에 선언 후 초기화
자료명 변수명1, 변수명2, 변수명3;
변수명1 = 값(리터럴);
변수명2 = 값;
...


//자료형이 같은 변수를 동시에 선언 및 초기화
자료명 변수명1 = 값(리터럴), 변수명2 = 값, ...;



<반복문 형식>

//for문
for (초기식; 조건식; 증감식) {
	실행문들;
	...;
}


//for무한반복문
for ( ; ; ) {
	실행문들;
	...;
}


//while문
기준식;
while (조건식) {
	실행문들;
	...
	제어식이나 제어어(break);
}


//while무한반복문
while (true) {
	실행문들;
	...
	제어식이나 제어어(break);
}


//do~while문
기준식;
do {
	실행문들;
	...
	제어식이나 제어어(break);
} while (조건식);


//do~while무한반복문
기준식;
do {
	실행문들;
	...
	제어식이나 제어어(break);
} while (true);



<상수(Constant)>

final 자료형 상수명 = 값(리터럴);
**반드시 대문자로 상수명 기술, 반드시 선언과 동시에 초기화



<배열>

같은 자료형을 가진 여러 개의 요소를 묶어놓은 집합체 형식

//선언
1. 자료형[] 참조변수명; (기본)
2. 자료형 참조변수명[];

//공간생성, 초기화

변수명 = new 자료형[] {값1, 값2, ...};
ㅡㅡㅡㅡㅡ


//선언 및 공간생성(메모리 할당)

자료형[] 변수명 = new 자료형 [방개수];

//초기화 
변수명[인덱스번호(방번호)] = 값1;
변수명[인덱스번호(방번호)] = 값2;
...
ㅡㅡㅡㅡㅡ

//단축형식 (선언 및 공간생성, 초기화)

자료형[] 변수명 = {값1, 값2, ...};
**new가 포함되어 있으며, 처음 설정한 값(요소)의 개수만큼 방 크기가 고정된다.



//new키워드
1. 데이터를 저장할 수 있는 공간을 만들어주세요.
2. 해당 공간에 해당 자료형(참조변수)의 내용을 복사해서 붙여넣어주세요.


//방번호, 방순서 = 인덱스 : 0 ~
//방크기, 방길이 = length



<지역인 경우>

변수와 배열객체의 요소값의 차이점
**변수는 지역일 경우 반드시 초기값 설정이 되어야 한다.
**배열객체는 지역일 경우 값이 없으면 자동으로 초기값 설정이 된다.

//자동 초기화 값

byte, short, int => 0
long => 0L
float => 0.0f
double => 0.0
char => '\n0000' (공백한칸)
String 자료형 포함 모든 참조자료형 => null



<for확장형>

//형식

배열변수
for (자료형 변수명 : 배열객체명) {

}

//예

int[] c = {1, 2, 3, 4, 5};
for (int i : c) {
	System.out.print(i + " ");
}

=> 1 2 3 4 5 




<이차원 배열>

행과 열로 이루어진 배열(바둑판)

//선언 및 행, 열 공간할당
자료형[][] 변수명 = new 자료형[행개수][열개수];


//초기화
변수명[행인덱스번호][열인덱스번호] = 값;
...
ㅡㅡㅡㅡㅡ

//선언 및 행 공간할당
자료형[][] 변수명 = new 자료형[행개수][];

//열 공간할당
변수명[행인덱스번호] = new 자료형[열인덱스번호];
...

//초기화
변수명[][] = 값;
...
ㅡㅡㅡㅡㅡ

//단축형식 (선언 및 공간생성, 초기화)
변수명[][] = {{값1, 값2, ...}, 
	{값1, 값2, ...}
}


//자료형[행][열] => 행 = row, 열 = column












<메소드(method)>

자바의 클래스에서 기능을 처리할 수 있도록 해주는 역할.
**리턴타입 기술부 필수.


//형식 (메소드 선언)

[접근제어자] [기타제어자] 리턴타입 메소드명([매개변수자료형 매개변수명, ...]){
	실행문들;
	.
	.
	.
	[return 리턴할 값;]
}

//메소드 선언 기능

1. 자바의 메소드는 반드시 선언이 되어 있어야 사용가능.
2. 메소드는 무조건 호출을 해야 실행된다.(자동실행x)
**단 main메소드는 JVM이 실행.



//형식 (메소드 호출)

메소드명([매개값...]);


//메소드 호출 기능

1. 메소드를 실행시킴.
2. 리턴 값을 받는 공간.


//메소드 호출 시 지켜야 할 사항

1. 메소드의 이름
2. 메소드의 매개변수 개수
3. 메소드의 매개변수 자료형
4. 메소드의 매개변수 나열순서(선언된 자료형 순서대로, 자료형 개수 만큼)




<메소드 오버 로딩(Over Loading>

동일한(같은) 이름의 메소드를 한 클래스에 여러개 만들어 두는것 (여러개 쌓아두는 것)


//조건

1. 반드시 매개변수의 개수가 달라야함
2. 반드시 매개변수의 자료형이 달라야함
3. 매개변수의 개수와 자료형이 일치하면, 반드시 나열순서가 달라야 한다.
4. 메소드의 이름이 동일해야 한다.




<클래스>

자바에서 데이터를 담기 위한 속성들(변수, 상수, 객체)과 어떠한 명령들을 처리하기 위한 기능들(메소드들, 생성자들, 초기화 블럭)의 집합
자바 파일의 최소 단위
**클래스에 멤버 - 속성, 메소드, 생성자, 초기화블럭 (4개뿐)


//클래스의 형식
[접근제어자] class 클래스명 {

	[접근제어자] [기타제어자] 자료명 -변수명;
			        -변수명 = 값;
	         예) filnal int MAX = 100;
		int max = 50;
		int[] marr = new int[3];
		String str = " ";
}



//초기화 블럭

[static] {
	실행문들;

}

[접근제어자] [기타제어자] 리턴타입 메소드명() {
	실행문들;
	[retuen = 값];
}



//생성자

[접근제어자] 클래스명() {
	실행문들;

}




- 일반 클래스

main 메소드 없음


- 메인 클래스 

main 메소드 있음



- 속성 : 필드, 컬럼, 멤버 변수, 인스턴스 변수, Attribute, property



<변수의 종류>

//생명주기

- 전역변수 

전역에 사용되는 변수
프로그램이 실행되어 선언된 시점부터 프로그램이 종료될 때 까지 살아있는 변수
(멤버변수, 등)

선언만 되어있으면 자동초기화 됨
동일한 이름으로 재선언이 한번 가능함


- 지역변수

지역 내부 안에서만 살아있는 변수
(메소드, 생성자, 반복문, 조건문(제어문))

동일한 이름으로 재선언이 불가능함



객체지향언어 (Object Oriented Programming language)
 자바



<객체선언 형식>

자료형 참조변수명 = new 자료형명();
ㅣ                    ㅣ ; (-선언)	         (-공간할당)
ㅣ	         ㅣ
ㅣ	         ㅣ
클래스급이상    ㅣ
	       (= 객체명, 인스턴스명 -> 주소값 저장)



- 인스턴스 : 원본 클래스 복제 후 메모리에 저장



변수선언 및 값 할당
//변수를 만들 수 있는 자료형: 기본자료형(byte, short, int, long, char, float, double)
자료형 변수명 = 값;

객체선언 및 공간 할당(클래스복제 = 인스턴스)
//객체를 만들 수 있는 자료형
//자바에서 제공해주는 자료형(예: String), 
//우리가 직접 만든 클래스
자료형(class이상) 객체명 = new 자료형(); //자료형() => 생성자호출문





<한 개의 java파일에 여러 개의 클래스를 기술할 때 public키워드를 붙일 수 있는 조건>
**클래스명과 자바파일의 이름이 동일해야한다.
 

- 일반클래스와 메인클래스가 섞여 있는 경우

1. 반드시 여러 개의 클래스 중에서 한 개의 클래스만 public키워드를 붙일 수 있다.
2. 반드시 메인클래스를 선언하는 곳의 접근제어자가 public 이어야 한다.
3. 파일명은 public키워드가 붙어있는 클래스의 이름과 동일해야 한다.


- 일반클래스들만 여러 개가 있는 경우

1. 반드시 여러 개의 클래스 중에서 한 개의 클래스만 public키워드를 붙일 수 있다.
2. 파일명과 동일한 이름의 클래스에만 public키워드를 붙일 수 있다.




<클래스의 멤버로 존재할 수 있는 것>
1. 속성(변수, 상수, 객체)
- 기능
2. 메소드
3. 초기화블럭
4. 생성자



<생성자(Constructor)>

클래스에서 인스턴스(객체)를 생성할 수 있도록 도와주는 기능을 처리함.
**생성자의 목적 : 클래스안의 멤버필드(속성)의 초기화를 진행.

1. 반드시 클래스명과 동일해야 한다.
2. 반드시 리턴타입을 기술하는 기술부 자체가 없다.
3. 객체생성문에서 new키워드 뒤에 호출이 된다.
ex) ExClass ec = new ExClass();
		ㄴ생성자호출문

4. 클래스안에 기술된 생성자가 한 개도 없으면 기본생성자가 숨어있다.
- 숨어있는 기본 생성자 :
	public 클래스명(){}
**숨어있는 기본 생성자의 접근제어자는 public, 직접 기술한 기본 생성자의 접근제어자는 다 가능.


5. 클래스안에 기타생성자가 한 개라도 기술되어있으면 기본생성자는 사라진다.
**기본생성자를 사용하려면 반드시 기본생성자도 기술해줘야 한다.



- default (기본) 생성자 형식 (매개변수가 없음.)

// public 클래스명() {}

[접근제어자] 클래스명() {
	실행문들;

}



- 기타 생성자 형식 (매개변수가 있음.)

[접근제어자] 클래스명([매개변수...]) {
	실행문들;

}





//형식

[접근제어자] 클래스명([매개변수...]) {
	실행문들;

}


vs

(메소드 형식)

[접근제어자] [기타제어자] 리턴타입 메소드명([매개변수...]){
	실행문들;
	.
	.
	[return 리턴할 값;]
}



//생성자 오버로딩 조건

**메소드 오버로딩 조건 모두 포함
**이름은 반드시 클래스명과 동일해야 한다.



//생성자호출문의 기능

1. 클래스를 복제한다. (= 객체생성)
2. 생성자안의 명령문 실행





<this키워드> : 기술할 수 있는 곳 - 메소드안, 생성자안 (순서x)

- this키워드는 반드시 멤버 앞에만 붙일 수 있다
- 단위가 객체이다
- 지역 앞에 붙을 수 없다
- (나를) this키워드를 감싸고 있는 멤버필드의 객체
- (나의) this키워드를 가지고 있는 인스턴스



<this()> 기술할 수 있는 곳 - 생성자안

1. 반드시 나와는 다른 생성자를 호출하는 호출문이어야 한다.
2. 반드시 생성자 안의 맨 처음 명령에 한번만 가능하다. 


//this();
인스턴스 기본생성자 호출문

//this(매개변수);
인스턴스 해당 케이스의 생성자 호출문 




 
- 비교대상이 변수인 경우는 == (동등비교연산자)의 의미는 값을 비교하는 연산자  (변수 - 값을 저장)
- 비교대상이 객체인 경우는 == (동등비교연산자)의 의미는 주소값을 비교하는 연산자 (객체 - 주소값을 저장)





<캡슐화(Encapsulation)> : 바로 노출되는 변수나 객체를 한 번 더 감싸서 직접 노출을 막기 위해 감싸는 것 (감싸는 기본 단위가 클래스)



<정보은닉(Imformation Hiding) = 보안> 
- 외부에서 멤버에 직접 접근을 하지 못하도록 막는 것(숨기는 것).
- 반드시 멤버필드의 접근제어자가 private가 되어야 한다.
- 반드시 멤버필드의 값을 가져오기 위해서는 반환값을 돌려줄 수 있는 public 메소드가 존재해야 한다.
							[default] 메소드도 가능은 하지만, public 권장




<접근제어자(Access Modifier)> : public > protected > default > private   (ppdp)
 


<import키워드>

나와 다른 패키지 안의 클래스나 메소드를 끌어올 때 소속을 명시하는 부분.

//형식

import 패키지경로.클래스명;
import 패키지경로.경로.경로...클래스명;



<객체(Object)> : 자바의 최상위 객체

어떠한 것을 독립적으로 표현할 수 있는 대상





메소드호출문
1. 메소드 실행
2. 리턴값이 있으면 그 값의 저장 공간


생성자호출문
1. 생성자 실행
2. 해당 케이스의 명령문 실행





<기타제어자 (Modifier)>

- final => ~할 수 없는, ~하지 못하는

- static => 정적(고정된), 공유 되는, 객체생성 없이 클래스 이름으로 접근 가능한 
							|
							ㄴ static메소드 안에서 this 대신 클래스 이름

- abstract => 추상적인, 몸체가 없는, 반드시 재정의 해야하는




<static 제어자>

static 키워드를 붙일 수 있는 것 : 멤버필드(속성), 메소드, 초기화블럭, 지역한텐 못씀

(static-멤버로 위장)

static메소드 안에서 멤버필드(속성)나 메소드를  호출, 선언 하려면 static키워드가 붙어있는 애들만 가능



(메모리 영역 - Method = static = class = 정적)





생성문에는 중괄호가 붙는다 / 이때 중괄호를 몸체라고 부름




<싱글톤패턴(Singleton)>
반드시 객체를 한 개만 생성하도록 강제적으로 제한하는 패턴(형식, 정해진것)


//조건
1. 반드시 private static 키워드와, 자료형이 내 자신의 클래스인 => 속성 하나가 선언되어야 한다.
2. 반드시 1번의 필드를 반환해주는 pubilc static 키워드가 붙은 getter메소드가 있어야 한다.
3. 반드시 생성자들의 접근제어자가 private으로 되어야 한다.




<변수들의 생명주기>
- 지역 변수
(탄생) : 지역변수가 선언된 시점
(죽음) : 지역변수가 포함된 메소드나 생성자의 명령이 모두 종료된 후

- 인스턴스 변수
(탄생) : 인스턴스가 선언된 시점(= 객체가 선언된 시점)
(죽음) : 인스턴스가 소멸되는 시점

- static변수 = 클래스변수 = 정적변수
(탄생) : 클래스가 메모리에 올라가는 시점부터(= 프로그램이 실행되는 시점)
(죽음) : 프로그램이 종료되는 시점





<UML(통합 모델링 언어, Unified Modeling Language)>

개발자가 필요한 요소들 정리
요소들의 관계 정리
요소들의 흐름들을 도식화(깔끔하게 양식화) 할때 사용하는 다이어그램

- 클래스 다이어그램 : 클래스, 인터페이스, 추상클래스 들 안에 필요한(속성,기능 정리) 조건 관리
		    해당 요소들간의 관계 정리

- 시퀀스 다이어그램 : 요소들이 어떻게 흐르는지의 절차를 정리




<클래스 다이어그램>

- 속성(변수, 상수, 객체)과 기능(메소드, 생성자)들을 보기 쉽게 정리하는 것
- 사각형으로 그려서 정리한다.
- 기술하는 방법이 정해져있다.





<String>


- String은 고정형 자료형이기 때문에 값이 변경되면 주소값도 변경된다
- String으로 만든 객체는 주소값이 아닌 값을 출력
- String에서 제공하는 모든 메소드는 원본 훼손이 일어나지 않는다


//String에서 제공하는 메소드(배운것들 작성) (String메소드)

- .concat("문자열")
해당 문자열을 문자열객체 뒤에 추가하는 메소드

- .length()
문자열의 길이 메소드

- .trim()
왼쪽 끝과 오른쪽 끝에 있는 공백 제거하는 메소드

- .charAt(값1)
값1에 해당되는 인덱스번호의 문자를 가져오는 메소드

- .substring(값1)
값1에 해당되는 인덱스번호부터 끝까지의 문자열을 가져오는 메소드

- .substring(값1, 값2)
값1에 해당되는 인덱스번호부터 값2 마이너스 1을 한 인덱스번호까지의  문자열을 가져오는 메소드

- .contains("문자열")
해당 문자열이 있는지 묻는 메소드 (리턴타입 boolean)

- .replace(a, b)
a를 b로 바꾸는 메소드

- .replaceAll([aaa], b)
[aaa]에서 a,a,a 하나하나 b로 바꾸는 메소드
**[ ]는 replaceAll에서만 사용가능

- .replaceAll([^aaa], b)
[^aaa]빼고 나머지를 하나하나 b로 바꾸는 메소드
**[ ]는 replaceAll에서만 사용가능

- .indexOf(문자열) : 해당 문자열의 맨 앞글자를 왼쪽에서부터 찾아서 해당 인덱스를 반환함.

- .indexOf(문자열, 인덱스번호) : indexOf(문자열)과 동일한데 해당 인덱스번호를 시작지점으로 인식하여 오른쪽으로 찾는다.

- .indexOf(아스키코드) : 해당 아스키코드 값에 문자를 찾아 인덱스를 반환함.

- .lastIndexOf(문자열) : 해당 문자열의 맨 앞글자를 오른쪽에서부터 찾아서 해당 인덱스를 왼쪽에서부터 세어 반환함.

-.lastIndexOf(문자열, 인덱스번호) : lastIndexOf(문자열)과 동일한데 해당 인덱스번호를 시작지점으로 인식하여 왼쪽으로 찾는다.

- .toUpperCase() : 싹 대문자로

- .toLowerCase() : 싹 소문자로

- .compareTo(문자열) : 문자열 비교, 값을 int로 반환

- .compareToIgnoreCase(문자열) : 비교 문자열의 대소문자를 똑같다 치고 compareTo(문자열) 함



- 패키지(클래스를 묶어놓은 집합체)
- import(다른 패키지를 끌어오세요)
- * (아스테리스크, 전체) 패키지안에 있는 모든 클래스에 import
	ex) import 패키지명.*


<Wraper클래스>

기본자료형을 클래스화 시켜놓은 자료형
String과 마찬가지로 특이클래스, 값이 바뀌면 주소값도 변경된다.

기본자료형 -> Wraper클래스 : Boxing (UpperCase)

Wraper클래스 -> 기본자료형 : Unboxing (LowerCase, DownCase)


숫자<>문자 형변환 할땐 클래스급으로 => (기본자료형 -> Wraper클래스 : Boxing)


기본자료형 <-> Wraper클래스  :  지들끼린 자동형변환 가능.

기본자료형을 Wraper클래스로 만드는 이유 >> 기본자료형의 Wraper클래스에 메소드를 사용하기 위함




<동일한 메소드 : 메소드명, 매개변수명, 매개변수 자료형 이 같은 메소드>



<상속(inheritance)>

나의 기능을 확장(extends), 나의 기능을 실체화(implements, realization)
부모에게서 물려 받은 것을 자식에게서도 사용할 수 있도록 하는것.

부모 : Super, 상위, 기본
자식 : Sub, 하위, 파생

//형식
확장(extends) : 반드시 부모와 자식이 동급인 경우
ex) 부모(클래스) 자식(클래스) / 부모(인터페이스) 자식(인터페이스)
public class ChildrenClass(자식클래스) extends ParentClass(부모클래스) { }
public interface ChildrenInterface (자식인터페이스) extends ParentInterface (부모인터페이스) { }

실체화(implements) : 부모와 자식이 급이 다른 경우, 인터페이스는 클래스를 상속 받을 수 없다.
public class ChildrenClass(자식클래스) implements ParentClass(부모클래스) { }


클래스급이상(클래스, 추상클래스, 인터페이스)인 경우 형변환은 반드시 상속관계에서만 형변환이 가능하다. 
아니면 String <> Wraper클래스 간 메소드를 이용해서 형변환

<상속 - 다형성(polymorphism)>

하나의 객체가 여러개의 자료형을 가지고 있는 것을 말함
=> 상속, 형변환 을 말함 => 필요한 이유는 메모리 낭비를 줄일 수 있다.

부모는 여러 자식을 품을 수 있음
자식은 부모를 품을 수 없음
자식은 지가 다 가질라함 -> 부모 Hiding, 부모꺼 내꺼처럼


<pacha케이스>
같은 이름 속성 : 부모것만		같은 이름 메소드 : 자식것만	(static메소드는 이름 같아도 부모것만)
다른 이름 속성 : 부모것만		다른 이름 메소드 : 부모것만

<chacha케이스>
같은 이름 속성 : 자식것만		같은 이름 메소드 : 자식것만
다른 이름 속성 : 부모자식 모두	다른 이름 메소드 : 부모자식 모두

상속관계에서도 오버로딩이 존재한다.
ex) 
(부)
public void md( ) //Hiding
public void md1(int a) -이놈
(자)
public void md( ) //Overriding -이놈
public void md1(String a) -이놈

이놈들 => 상속관계에서의 메소드 오버로딩




<오버라이딩(Overriding) 오버라이드(Override)>

부모와 자식간에 동일한 이름의 메소드가 존재하는 경우 자식의 메소드로 재정의(덮어쓰기) 되는 현상
(해당 메소드의 부모의 접근제어자 이상의 접근제어자를 사용해야 함)



부모와 자식관계에서 동일한 이름의 메소드가 있는 경우(매개변수까지 같은 동일 메소드)
부모 메소드가 가려지고(Hiding) 자삭의 메소드로 재정의(덮어쓰기) 되는 현상

//조건 
1. 반드시 상속관계가 존재해야 한다
2. 반드시 부모와 메소드가 동일해야 한다(매개변수까지 같은 동일 메소드)
3. 반드시 접근제어자가 부모 이상의 접근제어자로 선언되어야 한다
4. *********반드시 재정의(덮어쓰기) 되기 위해서는 리턴타입까지 동일해야 한다 (2번이랑 같은 말)

*private 처리된 부모의 속성은 상속되지 않는다




<Super키워드>

상속관계가 있을 때 부모 클래스에 호출(접근)하는 키워드
this키워드와 조건이 비슷함

super키워드 : 부모 인스턴스

super( ) 호출문 : 부모 인스턴스 안의 기본생성자 호출(자동으로 숨겨있다)
**자동으로 숨겨진 부모의 기본생성자는 실행되는 자식의 생성자 중 마지막으로 실행되는 생성자의 처음 명령에 숨어있다  *****마지막으로 실행되는 생성자*****
(단, 부모클래스에 기타생성자만 기술되어 있으면 오류 이럴경우 부모클래스에 기본생성자 기술하면 오류x)

super(매개변수) 호출문 : 부모 인스턴스 안의 해당 케이스의 기타생성자 호출(반드시 기술 해야한다.)






<상속의 캐스팅>

(상위 = <하위)
업캐스팅, 상위 자료형 생략가능, new한테도 업캐스팅 가능, 
하위는 상위의 자식자료형이여야 함

(하위 = <상위)
다운캐스팅, 하위 자료형 생략안됨, 상위 new한테는 다운캐스팅 불가능, 
하위는 상위의 자식자료형이여야 함


import키워드 - 다른 package를 사용하기 위한 - import 패키지명.패키지명....
package키워드 - class들의 소속 - package 패키지명




<추상클래스>

구현부(몸체)가 없는 메소드를 하나 이상 가지고 있는 abstract 키워드가 있는 클래스를 말함

- 키워드이며 기타생성자
- 클래스와 인터페이스 중간다리

//형식
[접근제어자] abstract class 클래스명 {

	//반드시 필수) public abstract 리턴타입 메소드명([매개변수들...]);

 }

//조건

1. class 정의시 abstract키워드가 붙어있어야 한다.
2. abstract클래스(추상클래스)는 반드시 abstract메소드를 한개 이상은 꼭 가지고 있어야 한다.
3. abstract메소드는 반드시 상속받은 자식클래스에서 재정의(Override)가 이루어져야 한다.
(자식클래스에서 재정의 되는 부분에는 몸체구현을 해야하며, abstract키워드가 제거된다.)
4. 객체생성을 할 수 없다. (생성자가 없는것이 아님)
(생성자, 메소드, 멤버필드 모두 가질 수는 있다.)
5. 객체생성 시 자식클래스로 생성 해야 한다.


<@(At기호)> : 어노테이션(Annotation) : 특수한 기능을 가진 주석

//형식
@명령이름





<인터페이스(Interface)>

추상메소드, 상수만 가지고 있는 집합체(묶음)

- 멤버필드에 변수는 상수만 있기 때문에 초기화까지 해줘야함


//형식

[접근제어자] interface 인터페이스명 {
	[public static final << 숨어있다] 자료형 상수명 = 값; //초기화까지 하거나, 선언만.
	ex)
	public static final int A = 5;
	int A = 5;	//앞에 public static final 숨어있음

	[public abstract << 숨어있다] 리턴타입 메소드명([매개변수들...]);
	ex)
	public abstract void setA(int a);
	void setA(int a);	//앞에 public abstract 숨어있음
}



//인터페이스의 조건
기능을 쉽게 바꿀 수 있도록 하기 위함.
보안을 위함.

1. 멤버필드는 반드시 public static final 상수만 가능
2. (권장) 메소드는 반드시 public abstract 메소드만 가능
3. 생성자를 가질 수 없다.
4. abstract 메소드는 반드시 자식클래스에서 재정의(Override) 되어야 한다.
5. 객체생성 시 자식클래스로 생성 해야 한다.



//인터페이스의 목적
1. 기능을 쉽게 바꿀 수 있다.(= 코드수정 용이. = 가독성이 좋다.)
2. 보안을 위해
***3. 다중 상속을 위해




//extends, implement

extends - 같은 급인 경우 사용하는 키워드
ex)
1. 자식클래스 extends 부모클래스
2. 자식클래스 extends 부모추상클래스
3. 자식인터페이스 extends 부모인터페이스


implement - 다른 급인 경우 사용하는 키워드
ex)
1. 자식클래스 implement 부모인터페이스
2. 자식추상클래스 implement 부모인터페이스
***인터페이스는 클래스를 상속 받을 수 없다 





상속자식에서 재정의시
abstract키워드는 사라짐
접근제어자가 부모이상의 접근제어자가 되어야함
반드시 몸체(구현부)가 있어야함




<Template Method>
GOF패턴(gang of four)
**형식이 정해져 있는 메소드를 말함
GOF패턴중 상속자식에서 재정의 하는 메소드의 양식을 변경할 수 없는 것은 행위패턴 중 하나



<POJO(Plain Old Java Object)>
기존의 순수한 자바 객체

//조건
1. 멤버필드가 (권장)private 처리 되어야 한다
2. 멤버필드의 값을 설정하거나 얻어갈 수 있는 접근제어자가 public인 gatter, setter 메소드가 존재해야 한다

//형식
[접근제어자] [기타제어자] class 클래스명 {
	private 자료형 필드명;
	....
	public 리턴타입 getter메소드() {return 값;}
	public void setter메소드(매개변수) {
		맴버필드 초기화 명령문 기술;
		//초기화 명령문 형식
		this.멤버필드명 = 매개변수명;
	}
 }



인터페이스끼리 상속관계일땐 오버라이드 불가능, 안해도됨, 못함 
=> 이유는 인터페이스가 abstract메소드만 가질 수 있기 때문. abstract메소드는 몸체가 없어서 안됨

인터페이스의 자식클래스에서 오버라이드 할때 다중상속(다형성)되어 있는 부모급 인터페이스들의 모든 abstract메소드를 오버라이드 해줘야함


<인터페이스의 기타생성자, private>
인터페이스에서 default, static 기타생성자의 기능은 조금 다름
접근제어자인 private의 기능도 조금 다름

- 인터페이스에서의 static키워드
1. 인터페이스의 statica메소드 또한 오버라이드 되지 않으며, 반드시 인터페이스명으로(해당 static메소드 앞에 인터페이스명.으로) 접근가능
(또한이라 한 이유는 클래스의 상속관계에서도 static메소드는 오버라이드 되지 않았다)
2. (자료형이 인터페이스인 객체)의 객체명으로는 접근불가
3. 상속받은 자식에서 재정의 하지 않아도 사용가능 하다

- 인터페이스에서의 default키워드(기타제어자로 사용)
1. 인터페이스에 선언된 default메소드에는 앞에 public을 기술해줘야한다
(public default로 기술, 메소드 앞에 아무것도 안쓸경우 인터페이스에선 //public abstract가 숨어있기 때문에 default를 쓰고싶으면 public default로)
2. 상속받은 자식에서 재정의 하지 않아도 사용가능 하다


- 인터페이스에서의 private키워드

1. 인터페이스의 private메소드는 상속 불가능, 재정의 불가능
2. 따라서 동일한 메소드(메소드명, 매개변수명, 매개변수 자료형 이 같은 메소드)가 존재해도
   별도의 독립적인 영역의 메소드로 인식한다.
   (같지만 같은 메소드가 아닌거)
   (pacha케이스에서 동일한 메소든데 부모메소드에 private처리가 되어있으면 같지만 다른메소드, 다른메소드로 인식해서 자식메소드 Hiding, 부모메소드는 private라서     외부접근 불가능)






<java.lang.String 메소드 추가>
 - .forName( 문자열 )
문자열 << 이 클래스의 패키지명.까지 다 붙여야 됨
문자열 << 이 클래스에 대한 정보를 알려줘, (ex)드라이버설치)
외부라이브러리를 사용하는 메소드

 - .toGenericString()
더 자세히

 - .toString()
오브젝트가 가지고 있는 메소드
모든 자식클래스에서 오버라이드해서 사용가능
재정의는 무조건 문자열로 출력 될 수 있게
 .앞의 해당클래스에 재정의해서 사용
 .앞의 해당클래스에 toString()메소드가 있는 경우 >> .앞의 해당클래스명을 출력하면 toString()메소드가 호출되고 리턴값 출력


 - 문자열객체명.split("구분자"[, 숫자값])
숫자값이 없는 경우 : nolimit = default (배열로 나누면서 연속적으로 끝까지 아무 값도 없는 경우는 배열에서 제외 됨)
	default는 0임
=> 해당 구분자를 기준으로 문자열 객체를 하나씩 나누어 문자열 배열 형태(반환타입 String[ ])로 만든다.
=> 해당 구분자는 삭제된다.
숫자값이 있는 경우 : (범위 지정 => (인덱스 - 1)배열까지)의 String[ ]로 나눈다.


 - .getChars(복사할 객체의 시작인덱스번호(int), 복사할객체의 마지막인덱스-1(int), 복사해서 붙여넣기 할 객체명, 붙여넣을 객체의 시작 위치 인덱스번호(int))
 매개변수 4개
 



<java.lang. 안에 유용한 메소드들>
 - Character.is~~()메소드들은 해당 요소에서 작은따옴표를 제외하고 안의 값만 그대로 가져와서 비교한다.
	~~에는 Digit, Letter, UpperCase, 등이 있음

 - Math.random()
숫자0과 숫자1 사이의 실수(0.~) 반환
(ex)
(Math.random() * a) + b
b부터 a까지 사이의 실수
정수로 받고 싶으면 메소드 앞에 (int)로 형변환

 - Math.abs(a) 
a의 절대값

 - Math.ceil 
무조건 올림처리

 - Math.floor 
무조건 내림처리

 - Math.rint   
반올림 처리

 - Math.max(a, b) 
a와b 중에 큰 값

 - Math.min(a, b) 
a와b 중에 작은 값







<java.util. 안에 유용한 메소드들>


 - random.nextInt()
int num = random.nextInt();
nextInt에 값 지정이 안되면 int의 유효범위 내의 정수가 임의 출력	//0포함

(ex)
int num = random.nextInt(11); 
//0부터 11개 >> 0 ~ 10 
//nextInt(a) a는 양수만 가능


float f = random.nextFloat();
0.0부터 1.0 사이의 임의의 실수 값


boolean b = random.nextBoolean();
임의의 논리값





//스캐너패키지 메소드
//가변형 자료형 StringBuffer
//Arrays클래스 메소드 >> 원본훼손 일어나는 메소드, 원본훼손 일어나지 않는 메소드









<초기화블럭(initializaion Block)>

필드(=속성=필드=인스턴스=Attribute=Property=컬럼=column)의 값을 초기화 시키는 기능을 가지고 있는 블럭

//형식
- 인스턴스 필드 블록 형식 : {필드의 초기화명령문; (static필드, 인스턴스필드)}
- 클래스 필드 블록 형식 : static{ 필드의 초기화명령문; (static필드)}

//초기화 순서
1번. 필드의 자동초기화값
2번. 필드선언 시 초기값 바로 대입하는 경우(명시적 초기화)
3번. 인스턴스 필드 블록 초기화값
4번. 클래스 필드(static필드) 블록의 초기화값
5번. 생성자에서 초기화한 값 
6번. setter메소드로 초기화한 값(단, setter메소드는 자동실행 안됨. 실행하려면 반드시 호출해야 함)

(ex)
class Ex {
	static int a = 10;	(1번) 명시적초기화
	{ a = 20; }	(2번) 인스턴스필드 초기화블록
	static { a = 55;}	(3번) 클래스(static)필드 초기화블록
	Ex() {
	a = 77;		(4번) 생성자 초기화
	}
 }



***멤버필드를 초기화 할 수 있는 방법

- 초기화 블럭 사용
- 생성자 사용 (this.머시기로)
- setter메소드 사용
- 명시적초기화 (선언과 동시에 값 대입을 하는 방법)

(명시적초기화 ex)
class Ex {
 int a = 1; //명시적초기화
 }


**필드(=멤버=속성=Attribute=property=컬럼=인스턴스 또는 클래스) 상수 예외사항
- 반드시 선언과 동시에 초기값 설정을 해주어야 하나, 생성자와 초기화블럭 중 딱 한 번은 초기값 설정을 할 수 있다.

(생성자로 상수 초기화 ex)
class Ex {
 	final int MAX; //만 하면 에러이지만
Ex() {
  	MAX = 10; //이걸로 한번은 가능(생성자)
	}
 }

(초기화블럭으로 상수 초기화 ex)
class Ex {
 	final int MAX; //만 하면 에러이지만
{
  MAX = 10; //이걸로 한번은 가능(초기화블럭)
	}
 }




<접근제어자(Access Modifier)와 기타제어자(Modifier)>

접근제어자 : public, protected, default, private
기타제어자 : final, static, abstract


//사용가능 범위 정리
===================================================
- 지역변수    : 접근제어자 모두 안됨, 기타제어자는 final만 가능
- 멤버필드    : 접근제어자 모두, 기타제어자는 abstract제외한 모두
- 메소드	     : 접근제어자 모두, 기타제어자 모두
- 생성자	     : 접근제어자 모두, 기타제어자 모두 안됨
- 초기화블록 : 접근제어자 모두 안됨, 기타제어자 static만 가능
- 클래스	     : 접근제어자 public, default, 기타제어자 static만 제외하고 가능
	      (단, 이너(inner) 클래스경우 예외)
===================================================

**같이 쓸 수 없는 제어자들
private 와 abstract
//abstract는 상속관계에서 쓰이는데 private는 같은 클래스 아니면 안보이니까 안됨
final 과 abstract
//abstract는 상속관계에서 쓰이는데 상속관계에서 final은 상속 할 수 없는 이란 뜻이라 안됨
static 과 abstract
//static은 공유되는 인데 abstract는 몸체가 없어서 공유고 뭐고 안됨




<제네릭타입(=지네릭타입=Generic Type)>
클래스, 메소드 에 가능
<>필수
사용자가 제네릭타입을 만드는 ex) class Ex<A> { 머시기 }

//형식
class 클래스명<클래스이상급자료형의 변수명(권장.대문자)>{
	클래스이상급자료형의 변수명 a;
	public 클래스이상급자료형의 변수명 getA() {
		return a;
	}
	public void setA(클래스이상급자료형의 변수명 a) {
		this.a = a;
	}
 }



<권장하는 제네릭타입>
 T => 한 개의 자료형을 변경하고자 하거나 어떤 변수를 지정할 지 잘 모르는 경우는 대개 T변수를 쓴다. (자료형을 의미하는 Type의 약자에서 따온 명칭)
 E => 배열처럼 나열하는 목록의 자료형을 가지는 클래스의 요소 자료형을 지정 할 때 사용하는 명칭(Element의 약자에서 따온 명칭) 
 K => Key요소의 자료형을 지정하는 명칭
 V => Value의 요소의 자료형을 지정하는 명칭
 N => Number자료형을 지정하는 명칭


<제네릭타입에서 <?> = 와일드카드>

? => 와일드카드 : 전체 다, 무엇이든지 => *(아스테리스크) 같은 놈





<컬렉션프레임워크(Collection Framework)>
한꺼번에 많은 데이터들을 처리하기 위한 구조, 형식을 제공하는 것. (배열같은)

//컬렉션프레임워크 형식
(자료형명<자료형명>) <- 자료형
ex) List<Car>
**컬렉션프레임워크는 제네릭기반의 자료형이므로 반드시 요소(제네릭타입)의 자료형은 클래스급 이상의 자료형으로 지정해 주어야 한다.


상속관계의 인터페이스로 되어있음

인터페이스 
	Collection인터페이스가 조상 인터페이스임
 - List인터페이스 -> ArrayList클래스, LinkedList, Vector, Stack, Queue(큐)
	=> 배열객체가 보완되어 나온 자료형, 방구조를 변경할 수 있다
	=> 중복값을 가질 수 있다. => 인덱스가 있기 때문에 (순서가 있다)	(ex. 0번인덱스에 1이 있어도 1번인덱스에 1을 담을수 있음)

	Collection인터페이스가 조상 인터페이스임
 - Set인터페이스 -> HashSet클래스, TreeSet클래스
	=> 리스트와 비슷하지만 중복값을 가질 수 없다.
	=> 순서가 없다. (인덱스가 존재하지 않음)

	Iterator(반복자)인터페이스가 조상 인터페이스임.
 - Map인터페이스 -> HashMap클래스, TreeMap클래스
	=> 키(key)와 값(value)의 쌍으로 이루어진 자료형 //<>제네릭타입을 두개 해줘야함 <하나 key꺼, 하나 value꺼>
	=> 키는 무조건(권장) 문자열자료형(String)으로 지정해 준다.
	=> 중복값을 가질 수 있지만, 중복키는 불가능하다.
	=> 순서가 없다. (인덱스가 존재하지 않음)






//18
//노트필기
//컬렉션프레임워크에 추가
//
//



<Collection Framework 종류와 형식>

- Collection인터페이스를 상속받은 자식 interface : List, Set
- Iterator인터페이스를 상속받은 자식 intetface : Map


List 인터페이스를 상속받은 자식 클래스 : ArrayList : 순서가 있다.(인덱스 존재, 중복값 허용)

//형식
List<자료형> 객체명 = new ArrayList<자료형>();
List<자료형> 객체명 = new ArrayList<자료형>([값(요소), 값(요소)2, 값(요소)3, ...]);
ArrayList<자료형> 객체명 = new ArrayList<자료형>();

//값(요소)추가 : 
- .add(추가할 값)메소드 : 마지막에 값을 추가한다.
- .add(인덱스번호, 추가할 값)메소드 : 해당 인덱스에 값을 추가하고 기존의 인덱스번호부터 ~ 마지막인덱스까지 한 칸씩 뒤로 밀린다.

//값(요소)삭제 : 
- .remove(인덱스번호) : 해당 인덱스의 값을 삭제한다.
- .remove(값) : 처음 인덱스부터 순서대로 검색하여 처음 해당되는 값만 삭제한다.
(중복값이 존재하는 경우는 맨 처음 값만 제거됨)

//해당값(요소) 모두 제거
- .removeAll(컬렉션프레임워크자료형객체) : 해당 자료형으로 지정해둔 값(요소)과 일치하는 값이 있으면 모두 제거함. 
---------------------------------------------------------------------------------
***컬렉션프레임워크자료형객체
*ex)
ArrayList<String> aAList = new ArrayList<String>();
aAList.add("홍길동");
aAList.add("고길동");
aAList.add("마이콜");
aAList.add("홍길동");

ArrayList<String> bAList = new ArrayList<String>();
bAList.add("홍길동");
aAList.removeAll(bAList); // aAList객체에서 홍길동이라는 이름이 모두 제거됨.
---------------------------------------------------------------------------------
- .clear() : 해당 객체를 주소값만 제외한 안의 방을 모두 제거함 



Set자료형 : 순서가 없는 자료형
(인덱스없음 = 중복값 불가)

//형식
Set<자료형> 객체명 = new HashSet<자료형>();
HashSet<자료형> 객체명 = new HashSet<자료형>();
- 순서가 있는 것 처럼 보이도록 처리할 수 있는 자료형 : LinkedHashSet자료형

//방추가 : List자료형과 동일
//방제거 : remove(값) 또는 remove(객체명)으로 제거 가능




Map자료형 : 순서가 없으며, 키와 값의 쌍으로 이루어진 자료형
(키는 중복값 불가, 값은 중복값 가능)
(키, 값에 null값 사용가능, 단 예외 자료형은 제외)

//형식
Map<키자료형, 값자료형> 객체명 = new HashMap<키자료형, 값자료형>();
HashMap<키자료형, 값자료형> 객체명 = new HashMap<키자료형, 값자료형>();
- 순서가 있는 것 처럼 보이도록 하는 자료형 : LinkedHashMap
- 키와 값에 null값을 허용하지 않는 자료형 : Hashtable

//추가 : .put(키명, 추가할 값);
//변경 : .put(키명, 변경할 값);
**키 중복이 허용되지 않으므로 키가 존재하지 않으면 put은 insert기능
**키가 존재하면 put은 update기능으로 처리됨.



=================================================
<객체의 크기(방길이, 문자개수, 행개수, 등등)를 나타내는 키워드 또는 메소드>

 - 배열객체의 방길이 : length
 - 문자열 길이(개수) : length( ) 메소드 
 - 컬렉션프레임워크 객체의 크기 : size( ) 메소드
=================================================


Iterator 인터페이스 자료형 : 한줄로 나열된(순서가 있던 없던 상관없음 - List, Set 가능) 데이터를 하나씩 떼어서 반복해서 가져올 수 있는 자료형 (StringTokenizer처럼)
- .hasNext() : 다음 요소가 있는지 확인, 데이터를 가져오지 않음. (boolean값으로 유무(true, false) 반환)
- .next() : 다음의 요소 한 개를 가져옴. 해당 값을 반환함

//형식
Iterator<자료형> 객체명 = 한줄로나열된객체명.iterator();
**제네릭형식으로 자료형을 반드시 기술해주어야 하나씩 요소를 떼어올 때 쉽게 가져올 수 있다.





<익명 클래스(Anonymous)>

- Inner class로, 이름이 없는 클래스를 말한다.
- 클래스 정의와 동시에 객체를 생성할 수 있다.

- Inerface, AbstractClass 모두 익명 클래스로 객체를 만 수 있다.
부모 클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의하기 때문에 하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없다. 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.

- 이름이 없기 때문에 생성자도 가질 수 없다.
- 인터페이스와 추상클래스 내부의 모든 추상메소드를 반드시 오버라이딩 해야 함.

- 마지막 }(종료중괄호) 뒤에 종료 ;(세미콜론)을 꼭 넣어준다. (매개변수로 생성하는 익명클래스는 종료세미콜론 없어도 됨)
- 외부에서 익명클래스의 멤버필드에는 접근불가.

- 익명클래스 내부에 기술가능한 static의 경우 : 
	1. static final로 선언된 상수(일반 변수 static은 불가)
	2. 외부 변수는 Effectively final나 final만 가능
	**Effectively final : 외부에 일반 변수라도 값 변경이 전혀 안 된 변수

//익명 클래스를 사용하는 이유
- 프로그램 내에서 한 번만 객체를 만드는데 사용되는 클래스를 굳이 정의할 필요가 없기 때문
- AWT, SWING, GUI, 이벤트 처리에 쓰임
- 외부에서 익명클래스의 멤버필드에 접근이 안되므로, 클래스 안에서 모두 처리되어야하는 경우만 익명클래스를 사용한다.

//형식
new 부모클래스이름( ) {
	//익명클래스 기술
 };

//형식2
new 구현인터페이스이름( ) {
	//익명클래스 기술
 }



<이너클래스(inner Class)>
내부클래스

클래스 안이나 메소드 안에 선언된 또 다른 클래스를 말함.
- 클래스를 선언 시 static 제어자를 사용 할 수 있다. (멤버의 개념)
- 클래스를 선언 시 접근제어자 모두 사용 할 수 있다.


//종류
- 인스턴스(instance) 내부 클래스 
클래스의 멤버 위치에 선언된 일반 클래스
외부에서 접근 할 수 있다.

- static 내부 클래스 
클래스의 멤버 위치에 선언된 static 클래스
외부에서 접근 할 수 있다.

- 지역(local) 내부 클래스 
메소드 안에 선언된 클래스
외부에서 접근 할 수 없다.



<람다식 함수>
- 이름 없는 함수
- 함수의 구현과 호출만으로 프로그램을 만들 수 있는 방식이다.
- 인터페이스만 이용 가능

- 외부에 정의된 변수를 참조할 때, final, 또는 Effectively final변수만 가능하다.
- 함수 내부에서 지역변수 선언시 final, 일반 변수만 가능, static불가
- 인터페이스 메소드를 참조하여 만들 경우 해당 인터페이스 내부에는 메소드가 한 개만 선언되어 있어야 한다. 여러 개 인 경우 에러 발생

- 람다식 메소드는 호출되면 익명클래스가 자동으로 생성된다. (눈에는 보이지 않음)
- 마지막 }(종료중괄호) 뒤에 종료 ;(세미콜론)을 꼭 넣어준다
- 자바 8버전부터 지원됨

//문법
(매개변수목록) -> {함수몸체};
한 줄 명령인 경우 중괄호 생략이 가능

리턴타입 메소드명(매개변수....){
 실행코드들....;
 }






<예외처리(Excetpion)>
예측가능한 에러를 정상종료가 되도록 처리하는 방법

Exception클래스 : 예외처리의 최고 조상 클래스(자료형)

//예외처리 방법
1. 책임감이 강한형식 :  try ~ catch문(짝, 반드시 같이 존재해야 함)
try문에서 발생된 에러는 catch문에서 해결함. 내가 발생시킨 에러를 내가 처리함

try문 : 해당 실행문들을 감싸는 위치에 존재
catch문 : try문에서 발생되는 에러를 처리하는 명령문을 감싸는 위치에 존재함

//형식
try {
       실행코드들;
        ...;
} catch (예외처리자료형명 객체명) { **//System.out.println(객체명); = 예외처리자료형명의 (패키지경로 포함)경로: 에러내용
    //try문에서 에러가 발생될 경우 처리할
      실행코드들;
      ...;
}[ finally{
에러가 발생이 되든, 발생이 되지 않든 반드시 try ~ catch문이 실행된 후 마지막에 실행되는 부분의 코드들을 기술;
} ]



2. 책임 전가형식 : throws
- 메소드를 호출한 곳에서 에러를 처리하도록 책임을 전가함
- 위치는 메소드 선언문의 () 소괄호 뒤에 존재함

//형식
[접근제어자] [기타제어자] 리턴타입 메소드명([매개변수들...]) throws 예외처리자료형명, ... {
	실행코드들...;
 }




<입출력 라이브러리는 java.io패키지에서 제공됨>

스트림 : 단방향으로 흐르는 데이터의 흐름을 스트림이라고 함.

바이트 스트림 : 그림, 멀티미디어, 문자 등 모든 종류의 데이터를 입출력할 때 사용
- 바이트코드화, 메모리 효율 좋음, 인코딩 등 해야 내가 알아볼 수 있음
문자 스트림 : 문자만 입출력할 때 사용
- 메모리 효율 안좋음, 내가 바로 알아볼 수 있음


바이트 스트림의 최상위 클래스 : InputStream(입력), OutputStream(출력)
하위 클래스 : 예) FileInputStream, FileOutStream

문자 스트림 최상위 클래스 : Reader(입력), Writer(출력)
하위 클래스 : FileReader, FileWriter



<스트림 : 단방향으로 흐르는 데이터의 흐름>

FileWriter => 문자열이나 char[]배열로 값 입력시 FileReader 객체를 통해 바로 읽어 들일 수 있다.

FileWriter로 입력을 하더라도 byte코드 한 개 한 개 입력하여 작성하는 경우는 반드시 byte코드를 문자스트림방식으로 변환해서 읽어야만 한다.

FileOutputStream => 바이트코드로 파일을 생성할 수 있다.

FileInputStream => 바이트코드로 파일을 읽어들일 수 있다. 바로 문자로 출력이 어렵기 때문에 InputStreamReader를 통해 문자스트림형식으로 변환 후 출력 가능하다.

FileOutputStream을 이용해서 파일을 작성할 때 인코딩을 설정하여 작성하는 경우 반드시 File을 읽어들일 때도 인코딩을 설정해서 읽어주어야 한다.





<프로세스(Process)와 스레드(Thread)>

프로세스 : 실행하고 있는 프로그램 또는 실행한 프로그램이 메모리에 올라와있는 상태를 프로세스라고 함

 - 단일프로세스 : 하나의 프로그램 당 하나의 프로세스만을 가지고 있는 것
	장점 : 메모리를 많이 차지 하지 않음, 속도가 빠름
	단점 : 하나의 프로세스에 문제가 발생하면 프로그램이 종료 됨

 - 멀티프로세스 : 하나의 프로그램 당 여러 개의 프로세스를 가지고 있는 것
	장점 : 하나의 프로세스에 문자가 발생되도 프로그램이 전체적으로 영향을 받지 않는다, 독립적으로 작업이 진행 됨
	단점 : 메모리를 단일프로세스보다 많이 차지함, 속도가 느릴 수 있다.
	예) 크롬브라우저

스레드 : 프로세스(프로그램) 안에서 실행되는 하나의 작업 단위를 스레드라고 함
하나의 스레드에서 문제가 일어나면 다 멈춤

 - 단일스레드 : 프로세스 안에 하나의 스레드만 존재함
	장점 : 메모리를 많이 차지 하지 않는다.
	단점 : 멀티작업을 진행하는 경우에는 멀티스레드보다 속도가 느릴 수 있다.

 - 멀티스레드 : 프로세스 안에 여러 개의 스레드가 존재함
	장점 : 멀티작업을 진행하는 경우에는 단일스레드보다 속도처리가 빠를 수 있다.
	단점 : 단일스레드보다 메모리를 많이 차지 한다.



자바에서는 기본적으로 한개의 스레드를 가지고 있다. (대표적 : main메소드)




<네트워크 필기>

v 인터넷 : 지역네트워크를 통신으로 연결한 것
v 네트워크 란 : 여러대의 컴퓨터들을 통신회선으로 연결한 것. 그물망처럼 연결된 통신망을 말함


v 네트워크 종류 : 
- PAN (Persnal Area Network) : 가장 작은 규모의 네트워크. 예시 : bluetooth
- LAN (Local Area Network) : 근거리 영역 네트워크. 예시 : Wi-Fi
- MAN (Metropolitan Area Network) : 대도시 영역 네트워크. 예시 : 대학교내의 통신망
- WAN (Wide Area Network) : 광대역 네트워크. 예시 : 핸드폰5G망 등
- VAN (Value Area Network) : 공중 통신 사업자로부터 통신 회선을 임대하여 하나의 사설망을 구축하고 이를 통해 정보의 축적, 가공, 변환 처리 등 부가 가치를 첨가한 후 불특정 다수를 대상으로 서비스를 제공하는 통신망
예시 : 은행 간 현금인출기 공동이용 서비스, 신용카드 정보 시스템, 국내외 항공사 간 항공권 예약 서비스
- ISDN (Integrated Services Digital Network) : 종합정보 통신망(=BISDN) 전화, 데이터 통신, 비디오텍스 등 통신관련 서비스를 종합하여 다루는 통합서비스 디지털 통신망. 디지털 전송방식과 광섬유 케이블 사용.


v 프로토콜(protocol) : 통신을 주고 받기 위한 통신 규칙. 컴퓨터와 컴퓨터도 서로 이해 할 수 있는 언어, 공용된 언어를 사용 해야 한다는 것


	v IP(Internet protocol address)(집주소-아파트(ip)) : 네트워크상에서 장치들이 서로 통신을 하기 위한 규칙에 필요한 서로를 식별하기 위한 고유 주소 또는 특수번호를 말함. (집 주소처럼 컴퓨터 주소라고 보면 됨. 하나의 랜카드 당 한 개의 ip가 할당되어 있다.)
**랜카드 : 네트워크를 사용하기 위한 어댑처 역할을 하는 장치
- IP는 흐름에 관여하지 않기 때문에 보낸 정보가 제대로 갔는지 보장하지 않는다. 전송과정에서 패킷이 손상될 수도 있고, 같은 호스트에서 전송한 패킷의 순서가 뒤죽박죽이 될 수도 있고, 같은 패킷이 두 번 전송될 수도 있으며, 아예 패킷이 사라질 수도 있기 때문에 패킷 전송과 정확한 순서를 보장하려면 TCP프로토콜과 같은 IP의 상위 프로토콜을 이용해야 한다.


	v 전송 제어 프로토콜(Transmission Control Protocol, TCP, 문화어: 전송조종(제어)규약(규칙)) : 웹 브라우저들이 월드 와이드 웹(www-대부분 웹이라고 함)에서 서버에 연결할 때 사용되며, 이메일 전송이나 파일 전송에도 사용된다.


v 포트(port)(집주소-아파트(ip) 동호수(port)) 란 : 같은 ip에서 접근해야하는 프로그램이 여러개 일 경우 해당 프로그램에 대해 접근하기 위해 부여된 프로그램 주소값이라고 생각하면 된다.


v 서버 : 서비스를 제공하는 프로그램을 의미함 (서비스를 제공하는 역할)
v 클라이언트 : 서비스를 요청하고, 받는 프로그램을 의미함 (서비스를 요청하고 받는 역할)
v 소캣(Socket) : 프로그램이 네트워크에서 데이터를 통신할 수 있도록 연결해주는 연결부


v ServerSocket 클래스(서버측) :
- java.net패키지에서 제공
- 서버 프로그램을 개발할 때 쓰이는 클래스
- 서버를 구동 시킬때, 요청을 받기위한 준비를 할때 사용
- 서버를 구동 시키는 것이므로 ip주소는 필요없으며, 자신의 서버에 제대로 접근할 수 있는 포트번호만 있으면 된다.
예시 : ServerSocket echoServer = new ServerSocket(4000); //4000이 포트번호임.

v Socket클래스(클라이언트측/서버측) :
- java.net클래스에서 제공
- client에서 서버로 접속하거나 Server에서 요청을 accept(수락)하는데 필요한 클래스
- 서버에 접근을 해야하므로 해당 서버의 ip주소와 해당 서버내의 프로그램이 부여받은 포트번호까지 필요하다.
예시 : Socket socket = new Socket("127.0.0.1", 4000);
	//서버의 ip주소: "127.0.0.1" , 서버의 포트번호: 4000
- 클라이언트의 요청을 수락해야하므로 Socket으로 요청한 자료형과 일치되는 Socket자료형으로 accept(수락)해주어야 함.
예시 : Socket socket = echoServer.accept();


v TCP/IP 송수신 과정
1. 서버 : 클라이언트의 요청을 받기 위한 준비를 한다. (ServerSocket)
   ServerSocket echoServer = new ServerSocket(4000);

2. 클라이언트 : 서버에 접속 요청을 한다. (Socket)
   Socket socket = new Socket("127.0.0.1", 4000);
2. 서버 : 클라이언트의 요청을 받아 들인다. (accept)
   Socket socket = echoServer.accept();

3. 클라이언트 : 서버에 메시지를 보낸다. (BufferedWriter)
3. 서버 : 클라이언트가 보낸 데이터를 출력한다. (BufferedReader)

4. 서버 : 클라이언트에에 메시지를 보낸다. (BufferedWriter)
4. 클라이언트 : 서버가 보낸 데이터를 출력한다. (BufferedReader)

5. 서버, 클라이언트 모두 종료 : 종료 한다. (socket.close())


v InetAddress 클래스
- InetAddress 클래스는 IP주소를 표현한 클래스임
- ip주소뿐만 아니라 도메인을 이용하여 ip정보를 가져올 수도 있다
- 자바에서는 모든 IP주소를 InetAddress 클래스를 사용한다
- default로 된 생성자가 하나 존재하나 객체 생성 불가
- 호스트 이름과 호스트에 대응하는 IP주소를 알 수 있는 메소드를 제공한다


v 객체를 반환하는 메소드(키워드가 모두 static 임)
- getAllByName(String host) : 매개변수 host에 대응되는 InetAddress 클래스 배열을 반환함
- getAddress(byte[] addr) : 매개변수 addr에 대응되는 InetAddress 클래스 객체를 반환함
- getByAddress(String host, byte[] addr) : 매개변수 host, addr로 생성한 InetAddress 클래스 객체를 반환함

- getByName(String host) : 매개변수 host에 대응되는 InetAddress 클래스 객체를 반환함
- getLocalHost() : 로컬호스트의 InetAddress 클래스 객체를 반환함

** Localhost(로컬호스트)는 서버의 기능을 제공하는 자신의 컴퓨터를 의미한다.
** IPv4에서의 IP주소는 127.0.0.1이다. (32비트 표현) 
(ip = 127.0.0.1 = 로컬호스트 => 나의 피씨를 인터넷에서 나만 볼 수 있는 주소이고 외부접근불가)
** IPv6은 32비트의 ipv4의 값의 표현이 제한적이라 보완되어 나온 물리적 주소 표기방법임. (128비트)


v 메소드
- getAddress() : InetAddress 클래스 객체의 실제 ip주소를 바이트 배열로 반환
- getHostAddress() : ip주소를 문자열로 반환
- getHostName() : 호스트 이름을 문자열로 반환
- toString() : ip주소를 String으로 오버라이딩한 메소드. "호스트이름/ip주소" 형식으로 값을 반환함.

내컴퓨터 ip => cmd >> ipconfig(간단히) / ipconfig /All(자세히)



<데이터베이스>

RDB(Relational DataBase) : 관계형데이타베이스
표구조의 데이터를 테이블이라는 구조화된 형식으로 저장, 변경, 삭제, 추가, 검색등을 지원하는 저장소

RDBMS(Relational DataBase Management System) : 
테이블 구조로 데이터를 저장하고, 변경하고, 삭제하고, 추가, 검색할 수 있는 그 이외에 데이터를 전반적으로 쉽게 관리할 수 있는 시스템을 말함.
종류 : Oracle, MySQL, MariaDB...
데이터는 무조건 테이블 구조로 저장이 된다. (다 테이블화 해버림)
영구적으로 데이터가 반영이 된다. (저장이된다) => 실질적으로 데이터는 파일로 저장이 된다.



<DBMS(데이터베이스 관리 시스템)의 장단점>
1. 장점
⇒ 데이터 중복의 최소화
파일 시스템에서는 각 응용 프로그램마다 자신의 파일이 개별적으로 관리 유지되기 때문에 전체적으로 저장되는 데이터의 입장에서 보면 상당히 많은 데이터가 같은 내용을 표현하면서 중복적으로 저장되고 있다. 그러나, 데이터베이스는 데이터를 통합하여 구성함으로써 이러한 중복을 사전에 통제할 수 있다. 이것은 물론 데이터의 중복을 완전히 배제한다는 것을 의미하는 것은 아니다. 왜냐하면 통합 데이터베이스 환경속에서도 성능 향상의 이유로 데이터의 중복이 불가피할 때가 있기 때문이다.

⇒ 데이터의 공용
같은 내용의 데이터를 여러 가지 구조로 지원해 줄 수 있는 DBMS의 복잡하고도 정교한 기법 때문에 데이터베이스의 데이터 공용이 가능하다. 이것은 기존 여러 응용 프로그램들이 수행하던 데이터에 대한 유지 관리 부담을 면제시켜 줄뿐만 아니라 새로 개발하는 응용 프로그램에 대해서도 데이터 구성에 신경 쓸 필요없이 응용 자체에만 전념할 수 있게 해준다는 것을 의미한다.

⇒ 데이터의 일관성 유지
현실 세계의 어느 한 사실을 나타내는 두 개의 데이터가 있을 때 오직 하나의 데이터만이 변경되고 다른 하나는 변경되지 않는다면 데이터간의 불일치성, 즉 모순성을 갖게 된다. 모순성을 내포한 데이터베이스는 서로 상충되는 정보를 제공하게 되고 데이터베이스의 유용성을 저해하게 된다. 데이터베이스는 관리 시스템은 바로 이 데이터의 중복을 제어하고 중앙 집중식 통제를 통해 데이터의 일관성을 유지할 수 있다.

⇒ 데이터의 무결성 유지
데이터 중복성이 완전히 제거된다고 하더라도 허용되지 않는 값이나 부정확한 데이터가 여러 가지 경로에 의해 데이터베이스에 잠입될 수 도 있다. 데이터베이스 관리 시스템은 데이터베이스가 생성/조작될 때마다 제어 기능(제약조건)을 통해 그 유효성을 검사함으로써 데이터의 무결성을 유지할 수 있다.
(NOT NULL, PRIMARY KEY, FOREIGN KEY등)

⇒ 데이터의 보안 보장
DBMS는 데이터베이스를 중앙 집중식으로 총괄, 관장함으로써 데이터베이스의 관리 및 접근을 효율적으로 통제할 수 있다. 이것은 DBMS가 정당한 사용자, 허용된 데이터와 연산등을 확인 검사함으로써 모든 데이터에 대해 철저한 보안을 제공한다.
일반적으로 같은 내용의 데이터가 여러 파일에 분산 관리될 때 같은 수준의 보장되기는 상당히 어렵다.

⇒ 표준화
DBMS의 중앙 통제 기능을 통해 데이터의 기술양식, 내용, 처리방식, 문서화 양식등에 관한 표준화를 범기관적으로 시행할 수 있다.

⇒ 전체 데이터 요구의 조정
한 기관의 모든 응용 시스템들이 요구하는 데이터들을 전체적으로 수집 분석하고 상충되는 데이터 요구는 조정해서 기관 전체에 가장 유익한 구조로 조직하여 효율적인 정보처리 효과를 얻게 할 수 있다.

2. 단점
⇒ 운영비의 증대
DBMS는 가격으로 보아 고가의 제품이고 컴퓨터 시스템의 지원을 많이 사용한다. 특히, 주기억장치를 많이 차지하기 때문에 DBMS를 운영하기 위해서는 메모리 용량이 더 필요하게 되고, 더 빠른 CPU를 요구하게 된다. 결과적으로 시스템 운영비의 오버헤드를 가중시키게 된다.

⇒ 자료 처리의 복잡화(DB데이타의 처리방법이 복잡해져 전문화된 프로그래머가 필요.)
데이터 베이스에는 상이한 여러 타입의 데이터가 서로 관련되어 있다. 응용 프로그램은 이러한 상황속에서 여러 가지 제한점을 가지고 작성되고 수행될지도 모른다. 다라서, 응용 시스템은 설계 시간이 길어지게 되고 보다 전문적, 기술적이 되어야 하기 때문에 고급 프로그래머가 필요하게 된다.

⇒ 복잡한 예비와 회복
데이터베이스는 그 구조가 복잡하고 여러 사용자가 동시에 공용하기 때문에 문제가 일어났을 때 정확한 이유나 상태를 파악하기 어려울 뿐만 아니라 여기에 대한 예비(Backup, 백업)조치나 사후회복 (Recovery, 복구)기법을 수립해 놓는 것도 매우 어렵다.

⇒ 시스템의 취약성
데이터베이스 시스템은 통합된 시스템이기 때문에 그 일부의 고장이 전체 시스템을 정지시켜 시스템 신뢰성과 가용성을 저해할 수 있다. 이것은 특히 데이터베이스에 의존도가 높은 환경에서는 아주 치명적인 약점이 아닐 수 없다.



<SQL(Structure Query Language)> : 구조화된 명령 언어

직접적으로 데이터를 관리하는데 사용하는 명령문


*SQL 문장
- 명령문은 대/소문자를 구별하지 않는다.
- 하지만 값은 대/소문자를 구분한다.
- SQL 문장은 한 줄 또는 여러 줄에 나눠서 입력할 수 있다.
- SQL 문장의 끝은 반드시 세미콜론(;)으로 끝을 맺는다.


**DML(Data Manipulation Language) 얘빼고 나머진 데이터 이상을 
: 데이터를 조작하는 명령어 = 데이터 조작어
: 데이터를 삽입, 삭제, 변경, 검색(조회)
insert 삽입 => 데이터 추가 기능 명령어
delete 삭제 => 데이터 삭제 기능 명령어 (데이터의 일부제거, 전체제거 가능)
update 변경 => 데이터 갱신(수정) 기능 명령어
select 검색 => 원본은 유지되지만 데이터를 검색해서 가져올 때 변형을 해서 가져올 수 있다. (검색, 조회)
*****반드시 영구적인 반영을 위해서는 TCL(확정 : commit, 되돌리기 : rollback)을 이용해야만 영구반영이 이루어진다.


DQL(Data Query Language) : 데이터를 가져오는 명령만 처리하는 명령문 = 데이터 질의어
select문


DDL(Data Defination Language) : 데이터를 저장하는 구조를 정의, 수정, 제거하는 기능을 처리하는 명령어 = 데이터 정의어
create : 테이블, 계정, 뷰, 프로시저, ...등을 생성할 때 사용하는 명령어
alter : 테이블, 계정, 뷰, 프로시저, ...등을 수정, 변경할 때 사용하는 명령어 (이름 변경까지 포함)
drop : 테이블, 계정, 뷰, 프로시저, ...등을 제거할 때 사용하는 명령어
truncate : 테이블의 구조만 제외하고 나머지 데이터를 모두 제거하는 명령어 (내가 지정한 테이블의 모든 데이터를 다 지우는 기능만 있다. 전체 삭제기능. 자동확정됨)


DCL(Data Control Language) : 데이터를 제어하는 기능을 담당하는 명령어 = 데이터 제어어
grant : 계정에 권한을 부여하는 명령
revoke : 계정의 권한을 회수하는 명령


TCL(Transaction Control Language) : 트랜젝션(작업)을 제어하는 명령어 = 트랜젝션 제어어
commit : 데이터베이스에 전체 데이터의 갱신결과를 영구적으로 확정하는 기능
rollback : 데이터베이스에 전체 데이터의 갱신 결과를 영구적으로 전체 되돌리는 기능
checkpoint(savepoint명령) : rollback하는 곳의 시점을 지정하여 전체 rollback이 아닌 원하는 지점까지의 rollback기능을 제공하는 명령어




//22
//필기



<오라클>


- 테이블 명명규칙
-------------------------------------------------------
테이블명은 문자로 시작해야 한다(한글포함)
테이블명은 128Byte이하 작성가능
테이블명은 문자(한글포함), 숫자, 특수문자($,_,#)까지만 사용가능
SQL키워드는 테이블명으로 사용불가
테이블 이름은 대소문자를 가지지 않는다
(단, 큰따옴표로 묶어 처리하는 경우 대소문자 가림)
동일한 계정내에서는 동일한 이름의 객체가 존재하는 경우 테이블명으로 사용할 수 없다 (테이블, 뷰, 함수, 프로시저, 등)
-권장
되도록 테이블명이나 컬럼명은 영어로 기재할 것
되도록 대소문자를 가리지 않도록 명명해줄 것.



- 컬럼(속성) 명명규칙
-------------------------------------------------------
컬럼명은 문자로 시작해야한다.(한글포함)
컬럼명은 문자(한글포함), 숫자, 특수문자($,_,#)까지만 사용가능하다.
SQL키워드는 컬럼명으로 사용할 수 없다.
한 테이블 내에서 동일한 이름으로 지정할 수 없다.




**큰따옴표를 묶어 지정하는 경우는 테이블명 컬럼명 모두 큰따옴표로 묶어야하며, DML, DDL, DCL, 등을 처리할 때도 반드시 큰따옴표로 묶어서 기술해야한다.
-------------------------------------------------------






1. 사용자(user) 계정 생성(create)
[CREATE문 : DDL]
형식 : CREATE USER 사용자계정명 IDENTIFIED BY 비밀번호;
>>예시 : CREATE USER TEST IDENTIFIED BY 1111;

2. 사용자 계정에 권한 부여
[GRANT문 : DCL]
형식 : GRANT 부여할권한1, 부여할권한2, .... TO 사용자계정명;
>>예시 : GRANT CONNECT, RESOURCE, DBA TO TEST;

3. 사용자 계정으로 접근하기(접속하기)
[CONNECT(CONN)문 : 종료세미콜론이 필요없는 문]
형식 : [CONNECT 사용자계정명/비밀번호] 또는 [CONN 사용자계정명/비밀번호]
>>예시 : CONNECT TEST/1111 또는 CONN TEST/1111

4. 테이블(table) 생성(create)하기
[CREATE문 : DDL]
형식 : CREATE TABLE 테이블명(
	컬럼명1 자료형 [제약조건1 제약조건2 ... ... ] , (뒤에 이어지는 컬럼이 있다는 , )
	컬럼명2 자료형 [제약조건1 제약조건2 ... ... ] ,
	...
	컬럼명N 자료형 [제약조건1 제약조건2 ... ... ] (마지막엔 , 없이)
);

4-1. 테이블 생성하기 (테이블 복제본만들기)
**테이블을 만드는 계정과 복제본을 끌어올 계정이 다른 경우는 복제본 테이블의 사용자계정명(스키마명)을 반드시 기술해주어야 한다.
형식 : CREATE TABLE 테이블명 AS SELECT * FROM [사용자계정명(복제할테이블이 속한)-스키마명].복제할테이블명;
**SCOTT계정에서 제공되는 테이블명 : EMP(사원관리 테이블), DEPT(부서관리 테이블), GRADE(등급관리 테이블)
-현재 접속 계정 : TEST인 경우
>>예시 : CREATE TABLE EMP AS SELECT * FROM SCOTT.EMP;
-------------------------------------------------------

**해당 계정내의 전체 테이블 목록 확인하는 명령 : SELECT * FROM TAB;
**해당 테이블의 전체 구조를 확인하는 명령 : DESC 테이블명;	[DESCRIBE]
**SQL PLUS : 오라클에서 무료(오픈소스)로 제공되는 COMMAND LINE INTERFACE 데이터베이스 개발툴

-------------------------------------------------------


* SQL 문법
- 대/소문자를 구별하지 않는다. 하지만 값은 대/소문자를 구분한다.
- SQL 문장은 한 줄 또는 여러 줄에 나눠서 입력할 수 있다.
- SQL 문장의 끝은 반드시 세미콜론(;)으로 끝을 맺는다.


* SELECT문
- DATABASE에 저장되어 있는 자원들을 검색할 때 사용하는 문장이다.
- 구성(문법 : 형식 : Syntax)

	SELECT [DISTINCT(중복값제외하는 키워드)] {*, 컬럼명1, 컬럼명2, ...}
	FROM 테이블명
	WHERE 조건;

- 모든 컬럼을 선택할 때는 "*" 를 사용한다.
하지만 "*"는 컬럼 검색과 함께 연산이 많아서 데이터베이스의 속도를 저하시킨다.





SELECT * | 컬럼명1, 컬럼명2 => 가져올 컬럼을 지정하는 절 : *(아스테리스크) => 전체 컬럼을 다 가져오세요.
FROM 테이블명 => 가져올 데이터가 존재하는 테이블명을 지정하는 절
--ㄴ필수-----------------조건ㄱ------
[WHERE  => 가져올 행 수의 조건을 지정하는 절
GROUP BY => 조건으로 가져온 것 중에서 동일한 값을 가진 컬럼이 있을 경우 그 값의 중복을 제거하는 절
HAVING => 위 GROUP BY절 조건에서 다시 조건을 거는 경우 (반드시 GROUP BY절이 존재해야 사용가능)
ORDER BY => 컬럼의 오름차순(ASC-생략가능,디폴트값), 내림차순(DESC) 지정하는 절]


-- : 오라클의 한 줄 주석 기호
/**/ : 오라클의 여러 줄 주석 기호

>>예시1)
SELECT NO, NM FROM USERLIST
WHERE NO = 2;

>>예시2)
SELECT * 
FROM USERLIST
(오라클한줄주석=>)--WHERE GENDER = '남';
WHERE NO = 1 OR NO = 2 OR NO = 6;
(WHERE NO = 1 AND NO = 2 AND NO = 6;) => 안됨 -표설명

>>예시3)
SELECT NM
FROM USERLIST
GROUP BY NM;

SELECT NM, GENDER
FROM USERLIST
GROUP BY NM, GENDER;
 = 그룹바이를 쓸때 그룹바이에 쓰는 컬럼만 셀렉트해야함

>>예시4)
SELECT NM, GENDER
FROM USERLIST
GROUP BY NM, GENDER
ORDER BY NM(오름차순으로 하고), GENDER DESC; (내림차순으로 마무리)



- 기본틀
SELECT 컬럼
FROM 테이블
[WHERE 조건]

--dept테이블에서 지역이 보스톤인 데이터의 부서명을 가져오세요
SELECT DNAME
FROM DEPT 
WHERE LOC = 'BOSTON';




EMP테이블 : 사원정보 테이블

컬럼명		자료형	코멘트
EMPNO		숫자형	사원번호
ENAME		문자형	사원명
JOB		문자형	직책
MGR		숫자형	상위관리자번호
HIREDATE	날짜형	입사일자
SAL		숫자형	연봉
COMM		숫자형	커미션
DEPTNO		숫자형	부서번호



DEPT테이블 : 부서정보 테이블

컬럼명		자료형	코멘트
DEPTNO		숫자형	부서번호
DNAME		문자형	부서명
LOC		문자형	지역(지점)


SELECT EMPNO, ENAME, DEPTNO
FROM EMP
WHERE ENAME = 'SMITH';

SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP
WHERE DEPTNO = 20;

사원정보 테이블에서 이름과 연봉과 입사일자를 가져와
SELECT 이름과 연봉과 입사일자
FROM 사원정보 테이블

입사일자가 81년 5월 1일 미만인 사원의 사번, 이름을 가져오세요
SELECT EMPNO, ENAME
FROM EMP
WHERE HIREDATE < '1981/05/01';

연봉이 3000이상인 사원의 모든 정보를 가져오시오
SELECT * 
FROM EMP
WHERE SAL >= 3000;




연산자 : 

우선순위 연산자 : ( )
산술연산자 : +(덧셈), -(뺄셈), *(곱셈), /(나눗셈 몫)
비교연산자 : > , >= , < , <= , = 
논리연산자 : AND (모든 조건이 참인 경우만 참, 나머지는 거짓)
	    OR (모든 조건이 거짓인 경우만 거짓, 나머지는 참)
	예시) DEPTNO >= 20 AND DEPTNO <=30   --->   DEPTNO BERWEEN 20 AND 30
DATE자료형(날짜자료형)
문자열결합 연산자 : ||
예시) '문자열1' || '문자열2'




//
//23
//필기
//

- SELECT문

SELECT * | 컬럼명들
FROM 테이블명 
WHERE  조건들
GROUP BY 그룹으로 묶을(묶어야 할) 컬럼들
HAVING 그룹으로 묶은 다음 다시 조건을 거는 경우
ORDER BY 컬럼의 오름차순(ASC-생략가능,디폴트값), 내림차순(DESC) 지정하는 절

- 해석순서
FROM절 -> WHERE절 -> GROUP BY절 -> HAVING절 -> SELECT절 -> ORDER BY절


//연습

DEPT 부서번호 부서명
SELECT DEPTNO, DNAME
FROM DEPT;

10번 부서에 해당하는 사원의 이름 급여 입사일자만 가져오는데
이름은 

SELECT ENAME, SAL, HIREDATE
FROM EMP
WHERE DEPTNO = 10;


SELECT절에서 중복값 제외하는 방법
SELECT DISTINCT DEPTNO, JOB FROM EMP;



- 비교 연산자
<, >, <=, >=
같다 =
다르다 <>, !=, ^=

- 논리 연산자
NOT, AND, OR

- SQL 연산자
BETWEEN 값1 AND 값2, IN (값1, 값2, 값3), LIKE , IS NULL, IS NOT NULL

형식 : 컬럼명 BETWEEN 값1 AND 값2 => 값1~값2 사이
형식 : 컬럼명 IN (값1, 값2, 값3) => 값1,2,3 이 포함되는
형식 : 컬럼명 LIKE '문자열값'
형식 : 컬럼명 IS NULL => NULL값에 해당되는 값이 있는지 확인하는 연산자
형식 : 컬럼명 IS NOT NULL => NULL값에 해당되지 않는 값이 있는지 확인하는 연산자
**오라클에서 NULL의 의미 : 어떤 값이 있는지 모른다, 비어있는 값, 빈 문자열


조건절들은 BOOLEAN값을 가져옴

//연습
10번 부서에서 CLERK직책인 사원의 사번, 이름, 직책, 부서번호
SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP
WHERE BETWEEN DEPTNO = 10 AND JOB = 'CLERK';



LIKE : 문자열 일부 포함여부
와일드카드 : 
% => 무슨 문자열이든 상관이 없다. = 어떤 문자열이든 올 수 있다, 몇 개가 오든 상관없다, 아무것도 오지 않아도 상관없다.
_ => 건너띄는 칸 수가 됨. = 문자 한개를 의미, 어떠한 문자가 오든 한 개

형식 : 컬럼명 LIKE '%값'; => 컬럼의 문자열에 앞에는 어떠한 문자든 올 수 있지만 마지막 문자열이 입력한 값으로 끝나는 문자를 가져옴
예) ENAME LIKE '%N' => 이름이 N으로 끝나는 정보를 가져옴
예) ENAME LIKE '%N%' => 이름 안에 N이라는 문자가 포함되는 정보 모두 가져온다.
예) ENAME LIKE 'N%' => 이름이 N으로 시작하는 정보를 가져옴
예) ENAME LIKE '_N%' => 앞 첫글자에 어떠한 문자가 오든 상관없이 단 한 개의 문자가 와야하고, 두번째 문자가 N이라는 문자가 포함되는 정보를 가져옴
예) ENAME LIKE '%N__(2)' => 앞 글자가 어떠한 문자가 몇 개 오든 상관없이 끝에서 세번째 문자가 N으로 끝나는 정보를 가져옴


- AND 연산자
true AND true : true
true AND false : false
true AND null : null
false AND false : false

false AND null : false
null AND null : null


- OR 연산자
true OR true : true
true OR false : true
true OR null : true
false OR false : false

false OR null : null
null OR null : null



* GROUP BY 형식
SELECT GROUP BY에서 설정한 컬럼들, 또는 그룹함수들
FROM 테이블명
WHERE 조건(어떤 컬럼이던 가능)
GROUP BY 그룹으로 묶을 컬럼명들
HAVING 그룹함수로 지정하는 조건 또는 GROUP BY에 설정한 컬럼으로 만드는 조건만 가능
ORDER BY 컬럼의 정렬을 지정;


* 그룹 함수

- 테이블 내의 행들에 대해서 연산한 후 단 하나의 결과 값으로 되돌리는 함수
- WHERE절에는 사용할 수 없다
- SELECT절, HAVING절 에 사용가능
- 반드시 GROUP BY를 해야만 컬럼과 함께 사용할 수 있다.
- GROUP BY가 없는 경우는 SELECT절에만 그룹함수 사용가능
- 종류 : 
합계 : SUM(컬럼명),
평균 : AVG(컬럼명),
최대값 : MAX(컬럼명),
최소값 : MIN(컬럼명),
행(줄) 수 : COUNT(컬럼명 또는 *) 등이 있음
- 그룹 함수는 NULL값을 제외한다. (COUNT(*)만 포함)


NVL함수 : NULL값을 다른 값으로 대체할 때 사용하는 함수
형식 : NVL(컬럼명, 대체할 값)



//연습
사원정보 부서별로 인원수
SELECT DEPTNO, COUNT(*)
FROM EMP
GROUP BY DEPTNO;

부서별로 연봉의 평균이 2000이상인 부서별, 연봉 평균 자료 가져와
SELECT
FROM EMP
GROUP BY DEPTNO, 
HAVING 





**DML(Data Manipulation Language) 얘빼고 나머진 데이터 이상을 
: 데이터를 조작하는 명령어 = 데이터 조작어
: 데이터를 삽입, 삭제, 변경, 검색(조회)
insert 삽입 => 데이터 추가 기능 명령어
delete 삭제 => 데이터 삭제 기능 명령어 (데이터의 일부제거, 전체제거 가능)
update 변경 => 데이터 갱신(수정) 기능 명령어
select 검색 => 원본은 유지되지만 데이터를 검색해서 가져올 때 변형을 해서 가져올 수 있다. (검색, 조회)
*****반드시 영구적인 반영을 위해서는 TCL(확정 : commit, 되돌리기 : rollback)을 이용해야만 영구반영이 이루어진다.




* INSERT명령문 : DML중에서 데이터의 행 수를 추가할 때 사용하는 명령문

--정식형식 : 테이블의 컬럼을 모두 지정하거나 일부만 지정할 때 사용가능 
(없는 값은 NILL값으로 자동처리/ 단, 지정한 기본값이 있는 경우는 해당 지정값으로 자동처리)

INSERT INTO 테이블명 (컬럼명1, 컬럼명2, ...)
VALUES (값1, 값2, ...);

예시) : DEPT01 =>
INSERT INTO DEPT01 (DEPTNO, DNAME, LOC)
VALUES (10, '운영');	//정식형식은 모든 컬럼을 다 채워주지 않아도 된다 (= 원하는 컬럼만 채워도 된다)
또는
INSERT INTO DEPT01 (LOC, DNAME, DEPTNO)
VALUES ('서울', '운영', 10);	//정식형식은 컬럼의 순서도 내맘대로 넣을수 있음

--단축형식 : 

INSERT INRO 테이블명 VALUES (값1, 값2, ...);
**조건 : 반드시 테이블에 있는 컬럼의 개수만큼 컬럼의 순서대로 모두 값(해당 자료형값)을 넣어야 한다.(컬럼명을 쓰지 않기 때문에 맞춰서 넣어야 하는거임) = 컬럼 개수, 컬럼 순서, 해당 자료형 값

예시) : DEPT01 => //컬럼의 순서 : (DEPTNO, DNAME, LOC)
INSERT INTO DEPT01 VALUES (10, '운영', '서울');

INSERT INTO DEPT01 VALUES (10, '운영'); (X-불가능)
INSERT INTO DEPT01 VALUES ('서울', '운영', 10); (X-불가능)



* UPDATE명령문 : 데이터를 부분 수정할 때 필요한 명령문 (줄 단위로 처리됨)

형식 : 

UPDATE 테이블명
SET 변경할 컬럼명 = 변경할 값1, 변경할 컬럼명 = 값2, ...
WHERE 조건들...
예시) : DEPT01 => 30번 부서인 부서명을 'CLERK'로 변경해라
UPDATE DEPT01
SET DNAME = 'CLERK'
WHERE DEPTNO = 30;



슈도컬럼(PSEUDO) : 처음에는 값이 정해져있지 않으나 실행이 될 때 값이 정해지는 컬럼(의사가 존재하는 컬럼)
- SYSDATE : 현재 날짜의 정보를 가지고 있는 예약어(연산자컬럼)




DELETE명령문 : 데이터를 줄(행) 단위로 삭제하는 경우 처리하는 명령문

형식 : 

DELETE 
FROM 테이블명 
WHERE 조건들...;

//연습
사원정보(EMP01)테이블에서 부서번호가 10인 사원만 제거
DELETE FROM EMP01 WHERE DEPTNO = 10;



//24
//필기
//



<CRUD>
C -> (CREATE) INSERT
R -> (READ) SELECT
U -> UPDATE
D -> DELETE



<DML : 데이터 조작어(DQL : SELECT포함)>
- INSERT : 추가
- DELETE : 삭제
- UPDATE : 변경
- SELECT : 검색, 조회



<SELECT형식>
SELECT 컬럼명 
FROM 테이블명 
WHERE 조건 
GROUP BY 그룹 조건 컬럼명 
HAVING 그룹에 대한 조건 
ORDER BY 컬럼에 대한 오름차순,내림차순(DESC);



//해당 테이블의 구조 보기
DESC 테이블명;



<INSERT형식>
1.
INSERT INTO 테이블명
(컬럼1,컬럼2,...)
VALUES
(값1,값2,...);

2.
INSERT INTO 테이블명 VALUES (값1,값2,...);



<UPDATE형식>
UPDATE 테이블명
SET 컬럼1 = 값1, 컬럼2 = 값2, ...
WHERE 조건들;



<DELETE형식>
DELETE FROM 테이블명
WHERE 조건들...;



<INSERT형식2 (여러 개의 테이블에 데이터 한꺼번에 추가하기)>
--모든 테이블이 같은 형식, 구조, 컬럼의 나열 순서까지 동일한 경우
--테이블명1과 테이블명2의 컬럼기술부를 제거할 수 있는데 => 해당 테이블의 전체 컬럼에 대해 순서대로 값을 넣는 경우만 가능
INSERT ALL
INTO 테이블명1
INTO 테이블명2
VALUES (값1, 값2, 값3, ...)	--값 자리에는 컬럼명으로 대체하여 들어온다.
SELECT (* | 컬럼명1, 컬럼명2, 컬럼명3, ...) FROM 데이터를 끌어올 테이블명 [WHERE 조건들...];

--테이블의 나열 순서는 동일하지만 컬럼의 개수가 다른 경우
INSERT ALL
INTO 테이블명 (컬럼1, 컬럼2) VALUES (값1, 값2)	--값 자리에는 컬럼명으로 대체하여 들어온다.
INTO 테이블명 (컬럼1, 컬럼2, 컬럼3) VALUES (값1, 값2, 값3)	--값 자리에는 컬럼명으로 대체하여 들어온다.
SELECT 컬럼명1, 컬럼명2, 컬럼명3 FROM 데이터를 끌어올 테이블명 [WHERE 조건들...];



//SELECT * FROM EMP WHERE 1=0;
테이블의 양식만 복사함






<DUAL 테이블>
- 오라클에서 제공되는 어느 계정에서나 접근 가능한 테이블
- 산술 연산이나 가상 컬럼 등의 값을 한 번(한 행(ROW))만 출력하고 싶을 때 유용하게 사용할 수 있는 테이블로서 DUMMY 라는 컬럼 한 개로 구성되어 있다.



<숫자함수>
- ROUND : 특정 자리수에서 반올림
형식 : 
ROUND (값) : 정수값으로 반올림한다.
ROUND (값, 소수점자리수) : 지정한 소수점자리수까지만 나타나도록 반올림한다.
예 : 
SELECT ROUND(345.678) FROM DUAL;
예 : 
SELECT ROUND(345.678, 2) FROM DUAL;
*값에 날짜도 가능
예 : 
ROUND (날짜, YEAR) : 6,7월 중 7월부터 반올림
ROUND (날짜, MONTH) : 15,16일 중 16일부터 반올림

- MOD : 나눗셈의 나머지값을 반환
형식 : 
MOD (피젯수, 젯수) : 피젯수를 젯수로 나눈 값의 나머지를 반환

- FLOOR : 소수점 자리수를 무조건 버림 (정수자리값만 표현되며 반올림처리 안함)
형식 : 
FLOOR (값) : 소수점을 지정하는 자리가 없음
예 : 
SELECT FLOOR(345.678) FROM DUAL;

- CEIL : 소수점 자리수를 무조건 버리고 정수자리값을 올림처리
정수자리값만 표현되며 일의 자리값이 무조건 올림처리 됨
형식 : 
CEIL (값) : 소수점을 지정하는 자리가 없음
예 : 
SELECT CEIL(345.118) FROM DUAL;

-TRUNC : 특정 자리수에서 버림
형식 : 
TRUNC (값) : TRUNC (값, 0)과 같음
TRUNC (값, 자리수) : 자리수 - (양수(소수점자리 지정), 음수(정수 자리수 지정))
*값에 날짜도 가능



<슈도컬럼(PSEUDO)> : 처음에는 값이 정해져있지 않으나 실행이 될 때 값이 정해지는 컬럼(의사가 존재하는 컬럼)
- SYSDATE : 현재 시각의 년/월/일 시:분:초에 대한 정보를 가지고 있음.
	출력시 년/월/일까지만 표현 됨.
	문자자료형과 DATE자료형 모두 가진다.

- SYSTIMESTAMP : 현재 시각의 년/월/일 시:분:초.밀리세컨드초 (UTC +시간정보)까지 가지고 있음.
		출력시 해당 정보 모두 표현 됨.
		DATE자료형만 가진다.



<문자함수>
- LOWER (소문자로 변환), UPPER (대문자로 변환)
형식 : 
LOWER ('문자열값'), UPPER ('문자열값')

- INITCAP : 첫 글자만 대문자로, 나머지는 소문자로 변환
형식 : 
INITCAP('문자열값')
예 : 
SELECT INITCAP('DATA BASE') FROM DUAL;
=> Data Base

- CONCAT (문자를 연결) : 문자열 결합 함수, 두 개의 단어만 결합가능
형식 : 
CONCAT('연결할 첫번째 문자열 또는 문자열자료형의 컬럼명', '연결할 두번째 문자열 또는 문자열자료형의 컬럼명')

- LENGTH : 글자의 개수, LENGTHB : 메모리에 차지하는 바이트 수
*영어, 숫자등은 1자당 1Byte, 한글은 버전에 따라 1자당 2Byte ~ 3Byte
형식 : 
LENGTH ('문자열값 또는 문자열자료형의 컬럼명')
LENGTHB ('문자열값 또는 문자열자료형의 컬럼명')

- SUBSTR : 문자열에서 원하는 문자열만큼 추출할 때 사용하는 함수
형식 : 
SUBSTR ('문자열값 또는 문자열자료형의 컬럼명', 시작위치, 추출할 개수)
*시작위치 : 
양수 : 정방향, 왼 -> 오
음수 : 역방향, 오 -> 왼
*값에 날짜도 가능

- REPLACE : 문자열 대체 함수
형식 : 
REPLACE('문자열값 또는 문자열컬럼명'. '구분자') : 대체할 문자는 기본값으로 빈문자열로 대체 됨
형식 : 
REPLACE('문자열값 또는 문자열컬럼명'. '구분자', '대체할문자') : 해당 구분자의 문자열이 대체할 문자로 변경 됨


<함수>
- INSTR : 특정 문자의 위치를 반환하는 함수
형식 : 
INSTR ('문자열값 또는 문자열자료형의 컬럼명', 찾을 글자)
INSTR ('문자열값 또는 문자열자료형의 컬럼명', 찾을 글자, 시작위치, 몇번째 발견)
*시작위치 : 
양수 : 정방향, 왼 -> 오
음수 : 역방향, 오 -> 왼
*N번째 발견
시작위치에서부터 가져올 N번째 발견 된 놈

- LPAD, RPAD (특정 기호로 채우기)
형식 : 
LPAD ('문자열값', 총 칸수, '채울문자 한 개')
RPAD ('문자열값', 총 칸수, '채울문자 한 개')

- TRIM (연속 된 특정 문자 제거하기)
형식 : 
TRIM ('제거할 문자' FROM '문자열값 또는 문자열자료형의 컬럼명')
LTRIM ('문자열값 또는 문자열자료형의 컬럼명', '제거할 문자')
RTRIM ('문자열값 또는 문자열자료형의 컬럼명', '제거할 문자')



<변환함수>
- TO_CHAR : 해당 값을 문자열로 변환해주는 함수
날짜 형식의 데이터를 문자열 형식으로 변환하는 경우
형식 : 
TO_CHAR (문자열로 변환 할 문자열이 아닌값, '포멧형식')
** 포멧형식
포멧형식은 반드시 문자열값으로 표현해준다.
YYYY 또는 YY : 년 4자리 또는 년 2자리
MM : 월 2자리
DD : 일 2자리
HH24 또는 HH12(=HH) : 24시간제 또는 12시간제
MI : 분
SS : 초
FF자리수 : 밀리세컨드초 (예: FF3 => .FFF)
AM : 오전 또는 오후
DAY : 요일
D : 요일을 숫자로 반환 (일-1, 월-2, ..., 토-7)

숫자값 데이터를 문자열 형식으로 변환하는 경우
형식 : 
TO_CHAR (숫자값, '000,000,000') : 총 9칸 준비 + 구분기호 개수(= 11)
=> 채워지지 않은 공간은 무조건 0으로 채운다.
TO_CHAR (숫자값, '999,999') : 총 6칸 준비 + 구분기호 개수(= 7)
=> 채워지지 않은 공간은 한 칸 공백으로 채운다.

** 만약 숫자값이라는 명시를 해주는 키워드가 붙을 경우에 
9 : 값이 있는 곳은 자리수 인식, 값이 없는 곳은 자리수를 무시한다.
0 : 값이 있든 없든 자리수 모두 인식하고 없는 자리수를 0으로 채운다.


- TO_DATE : 날짜자료형이 아닌 값(문자열값)을 날짜자료형으로 변환하는 함수
형식 : 
TO_DATE (날짜자료형값 또는 날짜자료형을 가진 컬럼명, '포멧형식')
** 포멧형식 TO_CHAR함수의 날짜 함수 형식과 동일하다.
** 날짜형식의 자료형 : DATE (년/월/일 -> 시분초정보 까지), TIMESTAMP (년/월/일 시:분:초.밀리세컨드초 까지)


- TO_NUMBER : 숫자가 아닌 값을 숫자형으로 변환하는 함수
형식 : 
TO_NUMBER ('숫자가 아닌 값 또는 컬럼명', '포멧형식')


- NVL : NULL값을 다른 값으로 대체할 때 사용하는 함수
형식 : 
NVL (컬럼명이나 값, NULL을 대체할 값)


- NVL2 : NULL값을 다른 값으로 대채할 때 사용하는 함수 중 하나
형식 : 
NVL2(컬럼명이나 값, NULL이 아닐 때 대체할 값, NULL일 때 대체할 값)


- POWER(N, M) : N의 M제곱승
예 : 
POWER(5, 3) => 5*5*5 = 125

- SQRT(N) : N의 루트(제곱근)값
예 : 
SQRT(9) => 3


//
//25
//필기
//


**SELECT절에 오는 모든 함수는 단일 값만을 반환하는 함수여야만 한다.

<DECODE 함수>(JAVA에 SWITCH문 유사)
형식 : 
SELECT DECODE(
기준컬럼명, 
케이스값1, 실행값1,
케이스값2, 실행값2, 
케이스값N, 실행값N,
마지막 실행값)		<<마지막 값 부분은 케이스값이 필요없음,
AS 별칭 FROM 테이블명;	    SWITCH~CASE의 default의 기능과 동일

<CASE WHEN 함수>(JAVA에 IF문 유사)
형식 : 
SELECT CASE [기준컬럼명, ]
WHEN 조건1 THEN 실행값1
WHEN 조건2 THEN 실행값2
...
ELSE 실행값
END AS 별칭 FROM 테이블명;


================================================

<DDL (데이터 정의어)>

생성 : CREATE문 
삭제 : DROP문
변경/수정 : ALTER문 - 컬럼의 (추가 ADD, 변경 MODIFY, 삭제 DROP, 이름변경 RENAME)
테이블의 데이터를 전체 영구삭제 : TRUNCATE
이름변경 : RENAME문


<<CREATE문>>

<테이블생성문 형식>
CREATE TABLE 테이블명(
컬럼명 자료형 [제약조건1 제약조건2 ...],
...
컬럼명 자료형 [제약조건1 제약조건2 ...]
);


<<ALTER문>>
(테이블이나 사용자 계정등의 정의(구조)를 변경하는 명령)

<(ADD)-테이블 컬럼을 추가하는 명령형식>
//제약조건 가능
-다중 컬럼 추가
ALTER TABLE 테이블명
ADD (추가할 컬럼명 자료형, 추가할 컬럼명 자료형, ..., 추가할 컬럼명N 자료형);

- 단일(한 개의) 컬럼 추가
ALTER TABLE 테이블명
ADD 추가할 컬럼명 자료형;

<(MODIFY)-테이블의 컬럼 정보를 수정하는 명령> 
//컬럼의 자료형을 변경하는데 해당 자료형과 다른 자료형으로 변경할 땐 컬럼의 데이터들이 모두 비어(NULL)있어야 한다
//같은 자료형으로 변경할 땐 들어있는 데이터 이상의 범위내에서만 줄이거나 늘릴 수 있음
//NUMBER자료형은 사이즈를 늘리는 것만 가능 (줄이는거 불가능)
//제약조건 불가
-다중 컬럼 수정
ALTER TABLE 테이블명
MODIFY (기존 컬럼명 변경할 자료형, 기존 컬럼명 변경할 자료형, ..., 기존 컬럼명N 변경할 자료형);

- 단일(한 개의) 컬럼 수정
ALTER TABLE 테이블명
MODIFY 기존 컬럼명 변경할 자료형;

<(DROP)-테이블의 컬럼을 삭제하는 명령형식>
- 단일(한 개의) 컬럼 삭제
ALTER TABLE 테이블명
DROP COLUMN 삭제할 컬럼명;

-다중 컬럼 삭제
ALTER TABLE 테이블명
DROP (삭제할 컬럼명, 삭제할 컬럼명, ..., 삭제할 컬럼명N);

<(RENAME)-테이블의 컬럼명 변경하는 명령형식>
ALTER TABLE 테이블명
RENAME COLUMN 기존의 컬럼명 TO 변경할 컬럼명;


<<RENAME문>> 
(테이블의 이름을 변경)

RENAME 기존의 테이블명 TO 변경할 테이블명;


DROP TABLE 테이블명;
DROP TABLE 테이블명 PURGE; //휴지통도 안가고 영구삭제
TRUNCATE TABLE 테이블명;



================================================



<자료형>
데이터타입, 컬럼(속성)에 들어갈 데이터의 유형을 결정한다.
//들어갈 값의 범위를 지정

문자형
CHAR(크기[BYTE]| CHAR) (고정형 문자 자료형) : 1~2000BYTE	예) CHAR(5 CHAR)
VARCHAR2(크기[BYTE]| CHAR) (가변형 문자 자료형) : 1~4000BYTE
LONG : 가변형 문자 자료형 : 최대 2GB까지 표현 가능(권장하지 않음. 이전버전화의 호환성을 위해 유지)

숫자형 - 정수, 실수 포함
NUMBER : 부동 소수점 자리수 숫자형	*입력한 숫자 그대로
NUMBER(자리수) : 정수값의 자리 수를 지정
NUMBER(소수점 제외 총 자리수, 소수점 자리수) : 고정 소수점 자리수 숫자형
정수값(총 차리수-소수점 자리수).지정한 소수점 자리수(초과된 소수점은 반올림으로 처리됨)
예) NUMBER(7, 2) => 12345.56 - 소수점 제외하고 총 자리수(1234556=7) , 소수점 자리수(.56=2)

날짜형
DATE : 년/월/일 시:분:초 까지 입력 가능한 날짜형 자료형
TIMESTAMP : 년/월/일 시:분:초.밀리세컨드초 까지 입력 가능한 날짜형 자료형

BIG DATA TYPE
BLOB : BINARY LARGE OBJECT -> 이진데이터 전용 큰 사이즈를 기술할 수 있는 자료형(최대 4GB - 1BYTE 까지 가능 //4기가 빼기 1바이트)
CLOB : CHARACTER LARGE OBJECT -> 가변 길이 문자데이터 전용 큰 사이즈를 기술할 수 있는 자료형(최대 4GB - 1BYTE 까지 가능)
**데이터 입력과 출력이 쉽지 않아 사용을 권장하지 않는 자료형이다.




//
//26
//필기
//



<테이블생성문 형식>
CREATE TABLE 테이블명(
컬럼명 자료형 [제약조건1 제약조건2 ...],
...
컬럼명 자료형 [제약조건1 제약조건2 ...]
);



<<제약조건>>
CONSTRAINT : 테이블의 속성을 지정할 때 해당 속성에 들어오는 값의 범위나 크기를 제외한 나머지에 대한 조건을 기술하는 것을 말함.


<NOT NULL 제약조건 (필수 입력)>
해당 속성의 값에 NULL값이 들어오면 안되게끔 하는 조건
형식 : 테이블을 설정할 때 
컬럼명 자료형 NOT NULL



<<데이터 무결성>>

* 무결 : 결점이나 결함이 없는 상태
* 데이터 무결성이란 데이터 베이스 내의 데이터에 대한 정확성, 일관성, 유효성, 신뢰성을 보장하기 위해 데이터 변경 혹은 수정 시 여러가지 제한을 두어 데이터의 정확성을 보증하는 것을 말한다. 관계형 관리시스템(RDBMS)에서는 설계 시 무결성을 고려한 설계로 데이터를 보호할 필요가 있다.
키 = 필드 = 컬럼 = 속성

* 제약조건 (CONSTRAINT)
1) 개체(객체) 무결성 (Entity integrity) => 기본키 (primary key => UNUQUE + NOT NULL)
**UNUQUE : 중복값 배제(단, 이놈은 NULL값 허용)
**NOT NULL : NULL값 배제(단, 이놈은 중복값 허용)
모든 테이블이 기본 키(primary key)로 선택된 필드(column)를 가져야 한다. 기본 키로 선택된 필드는 고유한 값(Unique-중복된 값을 허용안함)을 가져야 하며, 빈 값(Null)은 허용하지 않는다.
- UNUQUE 제약 조건 또는 PRIMARY KEY 제약 조건을 설정하여 테이블의 기본 키나 식별자로 사용되는 열의 무결성을 강제하도록 한다.

2) 참조 무결성 (Referential integrity) => FOREIGN (외래키) 
**(부모와 자식) 주종관계의 테이블이 존재해야 한다.
**노예테이블은 주인테이블이 주는 데이터만 받을 수 있음, 계속 받을 수 있음(중복가능), 안주면 없음(NULL가능), 주인테이블에 없는 데이터는 못받음
참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지되는 것을 말한다. 외래키와 관련있는 무결성. 외래키 값은 NULL이거나 참조 릴레이션의 기본 키 값과 동일해야함. 즉 릴레이션(= 테이블)은 참조할 수 없는 외래키 값을 가질 수 없다.

=============================================================================================================================

3) 도메인 무결성 (domain integrity)
열에 대한 데이터 무결성을 보장하기 위한 것으로 컬럼의 값이 널 값을 허용하지 않거나, 데이터 타입이 적절한지, 올바른 형식의 데이터가 저장되었는지 등을 확인하는 것이다. 
자료형지정, 체크(CHECK), 디폴트(DEFAULT), NOT NULL 등의 제약(constraints)들로 이러한 도메인 무결성을 보장할 수 있다. 예를 들어, 생일 날짜 컬럼에 알파벳이 입력되는 경우 도메인 무결성을 위반하는 것이라 볼 수 있다.
* 도메인 : 속성(Column) 하나가 가질 수 있는 모든 값의 집합.

=============================================================================================================================


<<키의 종류>>
1) 슈퍼 키 (SUPER KEY) => 2개 이상의 컬럼을 조합해서(복합키중에) 유일성이 만족되면 슈퍼 키
슈퍼 키는 테이블에 존재하는 필드들의 부분집합으로써, 유일성을 만족해야 한다.

2) 후보 키 (CANDIDATE KEY) => 기본 키가 될 수 있는 컬럼들
후보 키는 이름에서도 나타나듯이 기본 키가 될 수 있는 후보를 말한다. 후보키는 테이블에 존재하는 전체 필드의 부분집합으로써, 유일성(uniqueness)과 최소성(irreducibility)을 만족해야 한다. 유일성은 모든 레코드에서 해당 필드에 중복된 값이 나타나지 않는다는 속성이며, 최소성은 최소한의 필드로 레코드를 유일하게 구별할 수 있어야 한다는 속성이다.

3)** 기본 키 (PRIMARY KEY) => 반드시 한 테이블안에 PRIMARY KEY 조건은 한 개만 존재해야 함
기본 키는 테이블에서 특정 레코드를 구별하기 위해 후보 키 중에서 선택된 고유한 식별자를 말한다. 기본 키는 후보 키와 같이 유일성과 최소성에 대한 속성을 가져야 하며, NULL값을 가질 수 없다. 기본 키를 설정할 때는 아래와 같은 두 가지 사항을 고려하는 것이 좋다.

- 값이 자주 변경되지 않는 것을 선택 : 
기본키로 선택 된 필드에 저장되는 데이터가 많은 자리수를 갖는 정수거나 많은 문자를 포함하는 문자열이라면, 기본 키를 비교할 때 그 만큼 많은 비용이 소모 될 것이다. 그러므로, 짧고 단순한 형식의 데이터를 저장하는 필드를 기본 키로 설정하는 것이 DBMS의 성능 측면에서 유리하다.

4) 대체 키 (ALTERNATE KEY)
후보 키 중에서 기본 키로 선택 된 것들을 제외한 모든 키를 대체 키라고 한다.

5) 복합 키 (COMPOSITE KEY)
두 개 이상의 필드를 포함하는 키를 복합 키라고 한다. 앞에서 예를 들은 {id, dept_id}와 같은 키는 복합 키의 한 예시이다.

6)** 외래 키 (FOREIGN KEY) => 주테이블의 기본키로 만든 컬럼이 외래키
외래 키는 한 테이블의 키 중에서 다른 테이블의 레코드를 유일하게 식별할 수 있는 키를 말한다. 외래 키는 한 테이블의 레코드에서 다른 테이블의 레코드를 참조하기 위해 이용된다.

하나의 필드 또는 전체 필드의 부분집합으로 구성된다.
중복된 값과 NULL값을 가질 수 있다.
반드시 참조되는 테이블에서 유일한 값을 갖는 필드를 참조해야 한다. 예를 들어, 외래 키는 참조되는 테이블의 기본 키를 참조할 수도 있다.
참조되는 테이블에 존재하는 값만을 가져야 한다. NULL값은 실제로 존재하는 값은 아니지만, 많은 데이터베이스에서 NULL값은 예외로 한다.



<제약 조건 확인>

- P : PRIMARY KEY

- R : FOREIGN KEY (REFERENCES)

- U : UNIQUE

- C : NOT NULL, CHECK

데이터 딕셔너리 : 메타데이터(데이터를 위한 데이터)를 가지고 있는 테이블

제약조건에 대한 전반적인 데이터를 가지고 있는 데이터사전(데이터 딕셔너리) 테이블 :
USER_CONSTRAINTS


<데이터 딕셔너리 쿼리문 예시>

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP02';

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP03';




--PRIMARY KEY 조건
반드시 한 테이블안에 PRIMARY KEY 조건은 한 개만 존재해야 함
컬럼레벨 방식으로 기술하는 경우는 한 개의 컬럼에만 PRIMARY KEY 조건을 사용할 수 있다.
테이블레벨 방식으로 기술하는 경우는 여러 개의 컬럼을 조합(복합키)하여 PRIMARY KEY 조건을 사용할 수 있다.


--복합키로 기본키를 지정 : 반드시 테이블 레벨 정의 방법 이용 (컬럼레벨 정의 방법 불가)
**테이블레벨 정의 방법 :  컬럼을 정의하는 부분에 제약조건을 정의하는 방법



<제약 조건 이름 설정>
 
-- 제약 조건 이름(CONSTRAINT_NAME) 규칙

[테이블명]_[컬럼명]_[제약 조건 유형]
예: EMP04_EMPID_PK / EMPID_PK / EMP04_PK / PK
제약조건 정식형식 : CONSTRAINT 제약조건이름 제약조건유형
- 컬럼레벨 정의 방법 : 컬럼 안에 제약 조건을 같이 기술하는 것

<<해당 컬럼의 제약조건 검색>>
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_CONS_COLUMNS;




<제약 조건 추가, 삭제, 변경>

-- 추가 형식 : ADD CONSTRAINT 제약조건명 제약조건유형(컬럼명)
**NOT NULL은 ADD로 추가할 수 없기 때문에 MODIFY 에서 수정으로 추가해 줘야 한다.
- 예 : 
ALTER TABLE DEPT03
ADD CONSTRAINT DEPT03_DEPTNO_PK PRIMARY KEY (DEPTNO);



-- 수정 형식 : MODIFY 컬럼명 추가할제약조건
- 예 : 
ALTER TABLE DEPT03
MODIFY DNAME NOT NULL;



-- 삭제 형식 : DROP CONSTRAINT 제약조건명;
**NOT NULL은 제약조건명을 자동으로 부여받는 것만 가능하므로,
제약조건 데이터사전이나 제약조건을 검색하여 이름을 찾은 후 삭제 가능.
- 예 : 
ALTER TABLE DEPT03
DROP CONSTRAINT DEPT03_DEPTNO_PK;




<CHECK 제약 조건(값의 범위나 조건을 지정)>
- 입력 값이 조건에 맞지 않으면 DB에서 받지 않는다. 오류
- 입력 값의 범위를 지정 할 수 있다.
- 입력 할 수 있는 값의 범위를 설정해 줌

컬럼레벨 정의형식 : 
컬럼명 CONSTRAINT [제약조건명] [제약조건] (해당 컬럼값의 범위)
컬럼명 [제약조건명] [제약조건] (해당 컬럼값의 범위)

형식 : 
CREATE TABLE 테이블명 (
COL1 VARCHAR2(20) CONSTRAINT 제약조건명 제약조건,     --제약조건에 이름지정
COL2 VARCHAR2(20) CHECK(값의 범위나 조건 지정),    --이름을 지정하지 않는 경우
COL3 VARCHAR2(20)
);





<FOREIGN KEY(참조키, 외래키) 제약조건>
- 주인테이블의 기본키를 이용하여 노예테이블에 일반컬럼이나 기본키로 사용하는 방법
- 반드시 주인테이블의 기본키로만 이용할 수 있다.
- 반드시 주인의 기본키 속성(컬럼)안에 들어있는 값만을 가져다 쓸 수 있다. 그 이외의 값은 쓸 수 없다 (단, NULL은 사용가능)
- 주인의 기본키 속성값을 가져다 쓸 수 있으면서 중복으로 사용가능
 
컬럼레벨 방식 단축형식 : 
노예의 컬럼명 주인의 기본키자료형 REFERENCES 주인테이블명(주인테이블 기본키컬럼명)

정식형식 : 
CONSTRAINT [테이블명]_[컬럼명]_[제약조건명칭] FOREIGN KEY(노예테이블에 연결할 컬럼명) 
REFERENCES 주인테이블명(주인테이블 기본키컬럼명)


INSERT ALL INTO DEPT01 VALUES (DEPTNO, DNAME, LOC) SELECT * FROM DEPT;

SELECT * FROM DEPT01;

CREATE TABLE EMP06 (
EMPNO NUMBER(4) PRIMARY KEY,
ENAME VARCHAR2(10) NOT NULL,
JOB VARCHAR2(9),
DEPTNO NUMBER(4) REFERENCES DEPT01(DEPTNO)
);


- 주종관계가 존재할 때 주인테이블은 먼저 제거되지 않는다
- 주종관계가 존재할 때는 노예테이블 먼저 제거해야 한다.
- 주종관계가 존재할 때 주인테이블을 제거하려면 모든 노예테이블을 지워줘야 가능하다.
단, DROP TABLE 주인테이블명 CASCADE CONSTRAINTS; 을 사용하면 주인테이블만 제거가능





<DEFAULT 제약조건>
- 해당 속성(컬럼)에 아무런 데이터를 넣지 않는 경우 기본으로 넣을 값을 설정할 수 있는 조건

형식 : 
컬럼명 DEFAULT 해당 자료형에 맞는 값으로 지정
예 : 
컬럼명 자료형 DEFAULT 0 		--숫자형
컬럼명 자료형 DEFAULT '가'		--문자형
컬럼명 자료형 DEFAULT SYSDATE	--날짜형

**조건 : 반드시 제약조건 중 가장 처음에 기술해야 한다.
실질적으로 제약조건은 아님 그래서 제약조건란에 표시가 되지 않음




//
//27
//필기
//




TCL(Transaction Control Language) : 트랜젝션(작업)을 제어하는 명령어 = 트랜젝션 제어어
commit : 데이터베이스에 전체 데이터의 갱신결과를 영구적으로 확정하는 기능
rollback : 데이터베이스에 전체 데이터의 갱신 결과를 영구적으로 전체 되돌리는 기능
checkpoint(savepoint명령) : rollback하는 곳의 시점을 지정하여 전체 rollback이 아닌 원하는 지점까지의 rollback기능을 제공하는 명령어



<트랜잭션(Transaction)>
- 데이터베이스에서 데이터를 처리하는 하나의 논리적인 작업 단위를 의미

- COMMIT
  저장되진 않은 모든 데이터를 데이터베이스에 저장하고,
  현재의 트랜잭션을 종료하는 명령. 즉, 정상 처리되어 확정한다는 것
  Transaction(INSERT, UPDATE, DELETE) 작업내용을 DB에 저장.

- SAVEPOINT
  현재까지의 트랜잭션을 특정 이름으로 지정하는 명령.

- ROLLBACK
  저장되지 않은 모든 데이터 변경사항을 취소하고,
  현재의 트랜잭션을 끝내라는 명령.
   Transaction(INSERT, UPDATE, DELETE) 작업내용을 취소.

- 자동 COMMIT과 자동 ROLLBACK이 되는 경우
  SQL*PLUS 정상 종료는 자동 COMMIT, 비정상 종료는 자동 ROLLBACK
  DDL과 DCL 명령문이 수행 된 경우 자동 COMMIT



<트랜잭션 조건(ACID)>
1. 원자성(Atomicity) : 트랜잭션은 모두 다 정상적으로 완료되거나 아니면 모두 다 처리가 되지 않아야 한다.

2. 일관성(Consitency) : 트랜잭션은 어느 곳에서든 어느 시점에든 동일하게 데이터가 유지되어야 한다.

3. 독립성(= 고립성 = Isolation) : 하나의 트랜잭션이 실행되면 다른 작업은 해당 트랜잭션 중간에 끼어들 수 없어야 한다. 
트랜잭션은 다른 트랜잭션과 독립적으로 실행되어야 한다.

4. 영속성(= 지속성 = Durability) : 작업이 완료(COMMIT) 된 트랜잭션은 시스템의 에러가 발생되어도 영구적으로 데이터의 저장이 되어야 한다.






<<서브쿼리(SUB QUERY)>>
- 서브쿼리는 하나의 SQL문 안에 포함된 또 하나의 SELECT문을 의미함.
- 서브쿼리를 포함하고 있는 쿼리를 메인쿼리, 포함된 또 하나의 쿼리를 서브쿼리하고 한다.
- 서브쿼리는 비교 연산자의 오른쪽에 기술해야 하고 반드시 괄호로 묶어야 한다.
   (예외, INSERT ALL INTO 문의 SELECT절, CREATE TABLE 복제문의 SELECT절 등)
- 서브쿼리는 메인쿼리가 실행되기 전에 한 번만 실행된다.
- 단일 행 서브쿼리, 다중 행 서브쿼리 모든 서브쿼리의 SELECT절 안의 컬럼은 한 개여야만 한다.

<단일 행 서브쿼리(Single Row)>
- 오직 하나의 ROW(줄)만을 반환
- 단일 행 비교 연산자(=, >, >=, <, <=, <>)를 사용

<다중 행 서브쿼리>
- 서브쿼리에서 반환되는 결과가 하나 이상의 행일 때 사용
- 다중 행 연산자(IN, ANY, ALL)를 사용


<예시 : >
단일 행 서브쿼리
SELECT * FROM EMP WHERE DEPTNO >= (SELECT DEPTNO FROM DEPT WHERE DEPTNO = 10);
다중 행 서브쿼리
SELECT * FROM EMP WHERE DEPTNO IN (SELECT DEPTNO FROM DEPT WHERE DEPTNO <> 40);



<서브쿼리에서 그룹함수 사용법>
예시 : 평균 급여보다 더 많은 급여를 받는 사원 검색
SELECT ENAME, SAL FROM EMP 
WHERE SAL > (SELECT AVG(SAL) FROM EMP);



<ALL 연산자>
- 컬럼명 < ALL(100, 200, 300) -- 최소값(100)보다 작다. (소<소)
- 컬럼명 > ALL(100, 200, 300) -- 최대값(300)보다 크다. (대>대)

<ANY 연산자>
- 컬럼명 < ANY(100, 200, 300) -- 최대값(300)보다 작다. (소<대)
- 컬럼명 > ANY(100, 200, 300) -- 최소값(100)보다 크다. (대>소)




<서브쿼리를 이용한 데이터 추가>

INSERT INTO EMP03 
SELECT * FROM EMP;

INSERT INTO DEPT01 
SELECT * FROM DEPT;




<서브쿼리를 이용한 데이터 변경>

UPDATE DEPT01
SET LOC = (SELECT LOC FROM DEPT01 WHERE DEPTNO = 40)
WHERE DEPTNO = 10;

- 서브쿼리를 이용한 두 개 이상의 컬럼에 대한 값 변경(단일행 다중컬럼)
UPDATE DEPT01
SET (DNAME, LOC) = (SELECT DNAME, LOC FROM DEPT WHERE DEPTNO = 30) 
WHERE DEPTNO = 10;

- 서브쿼리를 이용한 두 개 이상의 컬럼에 대한 두 개 이상의 값 변경(다중행 다중컬럼)
UPDATE DEPT01
SET DNAME = (SELECT DNAME FROM DEPT WHERE DEPT.DEPTNO = EMP01.DEPTNO);




<서브쿼리를 이용한 데이터 삭제>

DELETE FROM EMP01
WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME = 'SALES');







<기존 테이블 데이터까지 복제할 때 새 테이블에 컬럼 추가하면서 만드는>

CREATE TABLE EMP01
AS SELECT '테이블별칭'.*, '한번에 지정할 값' AS DNAME FROM 가져올테이블 '테이블별칭';
**테이블의 별칭은 AS 사용불가 반드시 한칸공백으로 구분



<기존 테이블 데이터까지 복제 방법2>

CREATE TABLE EMP01
AS SELECT 테이블별칭.* FROM 가져올테이블 테이블별칭;





//
//28
//필기
//




<<조인 (JOIN)>>

**JOIN은 각 테이블간에 공통된 컬럼(조건)으로 데이터를 합쳐 표현하는 것.


//조인의 유형

<내부 조인 (INNER JOIN) : (= 교집합)>
- 두 테이블에 공통으로 존재하는 컬럼을 이용하여 합치는 방식

1. 동등 조인 (Equi Join) : 공통 존재 컬럼의 값이 같은 경우를 추출하는 조인 방식
(INNER JOIN, ANSI INNER JOIN)

2. 교차 조인 (CROSS JOIN) : 조인 조건이 없는 조인 방식
(CROSS JOIN, ANSI CROSS JOIN)



<외부 조인 (OUTER JOIN) : (= A 또는 B 또는 합집합)>
- 특정 테이블의 모든 데이터를 기준으로 다른 테이블의 정보를 추출(다른 테이블에 값이 없어도 출력됨)

1. 왼쪽 외부 조인 (LEFT OUTER JOIN) = A : 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터를 추출
(LEFT OUTER JOIN, ANSI LEFT OUTER JOIN)

2. 오른쪽 외부 조인 (RIGHT OUTER JOIN) = B : 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 동일 데이터를 추출
(RIGHT OUTER JOIN, ANSI RIGHT OUTER JOIN)

3. 완전 외부 조인 (FULL OUTER JOIN) = 합집합 : 양쪽의 모든 데이터를 추출
(ANSI FULL OUTER JOIN)



*Equi Join (동등 조인, 가장 많이 사용)
- WHERE절에서 조인 조건을 사용 (권장사항 : 조인 조건 개수 = 연결 테이블 수 - 1 이상)
- 명확성을 위해 컬럼명 앞에 테이블명 또는 테이블 별칭을 설정

형식 : 
SELECT [테이블별칭1.]컬럼명, [테이블별칭1.]컬럼명, [테이블별칭2.]컬럼명, [테이블별칭2.]컬럼명
FROM 테이블명1 [테이블별칭1], 테이블명2 [테이블별칭2]
WHERE 테이블명1.동일한값의컬럼명 = 테이블명2.동일한값의컬럼명

--부서번호를 기준으로 같은 값을 가진 사원 테이블과 부서 테이블 결합 
SELECT ENAME, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;



*Self Join : 동일 테이블 사이의 조인 
- 반드시 테이블의 별칭이 존재해야 한다.
- 반드시 컬럼을 명시할 경우 테이블의 별칭을 생략할 수 없다.




**ANSI Join (미국표준연구소 표준 조인)
- 다른 DBMS와의 호환성을 위해서는 ANSI 조인을 사용하는 것이 좋다.

*ANSI Inner Join (동등조인과 동일하게 처리)
형식 : 
SELECT [테이블별칭 또는 테이블명.]컬럼명1, ...
FROM 왼쪽기준이되는 테이블명 [테이블별칭]
[INNER(디폴트)] JOIN 오른쪽기준이되는테이블명 [테이블별칭]
ON 조인조건
WHERE 조인조건 이외의 조건 기술; 




**USING을 이용한 조인 조건 지정, ON대신 사용가능.
(단, 조인 조건에 사용되는 컬럼명이 동일해야 한다.)
USING을 사용하는 경우 해당 컬럼이 맨 앞에 딱 한 번만 표현된다.

형식 : 
ON 테이블1의(컬럼명) = 테이블2의(컬럼명) (두 컬럼명이 같을 때)
=> USING (컬럼명)




<외부 조인>
- OUTER JOIN : 2개 이상의 테이블이 조인될 때 어느 한쪽 테이블엔 데이터가 존재하는데, 다른 쪽 테이블에는 데이터가 존재하지 않는 경우에, 데이터가 누락되는 문제를 해결하기 위해 사용되는 조인 기법임.


1. LEFT OUTER JOIN : FROM절의 테이블에 해당되는 값을 모두 표현하고, 그 뒤에 JOIN절에 해당하는 테이블의 값을 표현하는 방식. 해당 값이 없는 컬럼은 NULL처리 함. (LEFT OUTER JOIN, ANTI LEFT OUTER JOIN)


2. RIGHT OUTER JOIN : JOIN절에 해당하는 테이블의 값을 모두 표현하고, 그 뒤에 FROM절의 테이블에 해당되는 값을 표현하는 방식. 해당 값이 없는 컬럼은 NULL처리 함. (RIGHT OUTER JOIN, ANTI RIGHT OUTER JOIN)


3. FULL OUTER JOIN : 조인할 두 테이블의 값을 모두 표현하고, 해당 값이 없는 컬럼은 NULL처리 함. (ANSI FULL OUTER JOIN)
FULL OUTER JOIN은 ANSI조인만 가능하기 때문에 (+)아우터 연산자를 사용하지 못한다


*조인에서 권장사항 : 최대 5개 이상의 테이블 정도만 조인해라



<**여러 개의 테이블을 JOIN>
여러개의 JOIN절이 존재할 경우 반드시 JOIN절 마다 ON절이 존재해야 한다.

SELECT E.EMPNO, E.ENAME, D.DEPTNO, S.DEPARTMENT_NAME 
FROM EMP E
JOIN DEPT D 
ON E.DEPTNO = D.DEPTNO
JOIN DEPARTMENTS S 
ON E.DEPTNO = S.DEPARTMENT_ID;




<(+) : OUTER 연산자의 조건>

- 하나의 조건에 존재하는 컬럼에 동시에 사용할 수 없다.
예)
EMP.DEPTNO(+) = DEPT.DEPTNO(+) [불가능] / EMP.DEPTNO(+) = DEPT.DEPTNO [가능]

- 여러 개의 테이블을 조인하는 경우 아우터 연산자는 동일한 테이블의 동일한 컬럼에 아우터 연산자를 연속하여 사용할 수 없다.
예)
EMP.DEPTNO(+) = DEPT.DEPTNO AND EMP.DEPTNO(+) = DEPARTMENTS.DEPARTMENT_ID [불가능]
EMP.DEPTNO(+) = DEPT.DEPTNO AND EMP.DEPTNO = DEPARTMENTS.DEPARTMENT_ID(+) [가능]




<USING(컬럼명) 조건>

- 반드시 조인하는 테이블에 동일한 컬럼이 존재해야 한다.
- 반드시 SELECT절의 컬림이 *(전체)인 경우만 가능하다.




<세미 조인(SEMI-JOIN)>
IN, EXISTS 연산자를 이용해 서브쿼리에 있는 데이터에 대해서만 메인쿼리에 추출하는 조인 방법

예 : 
SELECT * FROM DEPT B
WHERE EXISTS(SELECT * FROM EMP E WHERE E.DEPTNO = B.DEPTNO);



<안티 조인(ANTI-JOIN)>
NOT IN, NOT EXISTS 연산자를 이용해 서브쿼리에 없는 데이터만 메인쿼리에서 추출하는 조인 방법

예 : 
SELECT * FROM DEPT B
WHERE NOT EXISTS(SELECT * FROM EMP E WHERE E.DEPTNO = B.DEPTNO);

예 : 
SELECT * FROM EMP E
WHERE NVL(E.DEPTNO, 0) NOT IN(SELECT DEPTNO FROM DEPT);




<카타시안 조인(CATASIAN PRODUCT)>
조인 조건이 없는 조인
안시조인이 아닌 교차조인(CROSS JOIN)
- 컬럼은 해당 테이블의 컬럼을 모두 합한 개수만큼 
- 행(줄)은 해당 테이블의 행(줄) 수를 모두 곱한 개수만큼
예 : 
SELECT * FROM EMP E, DEPT D;






//
//29
//필기
//





<<View(가상테이블)>>

- 테이블과는 달리 데이터 저장공간이 없다.
- 뷰는 단지 쿼리문을 저장하고 있는 객체.

- 뷰는 실제 자료를 갖지 않지만, 뷰를 통해 테이블을 관리할 수 있다.

- 하나의 테이블에 뷰의 개수는 제한이 없다.

- 뷰이름 권장사항
view_테이블명
테이블명_view
view_테이블명1_테이블명2

- 문법 (Syntax = 형식)
CREATE VIEW 뷰이름
AS
SELECT 컬럼명 FROM 테이블명 [WHERE 조건];



<뷰 성격에 따른 가능 범위>

- <단순뷰 (SIMPLE VIEW)> : 
VIEW를 생성할 서브쿼리에 조인 조건없이 1개의 테이블로 만들어지는 간단한 VIEW. 하나의 TABLE에서 뽑아오며 함수를 사용안한다.
DML(INSERT, UPDATE, DELETE) 사용 가능

- <복합뷰 (COMPLEX VIEW)> : 
여러 개의 테이블이 JOIN되어 생성되는 것. 하나 이상의 TABLE에서 뽑아오며 함수(GROUP BY HAVING등과 같은 함수)를 사용한다.
DML(INSERT, UPDATE, DELETE) 사용 *불가능

- <인라인 VIEW (INLINE VIEW)> : 
여러 번 사용할 필요없이 1회만 필요한 VIEW일 경우 SQL명령의 FROM절에 VIEW의 서브쿼리 부분을 바로 적어주면 되며 이런 일회용 VIEW를 말함.





//*CREATE OR REPLACE VIEW 뷰이름 FROM 테이블 WHERE 조건;
- 해당 뷰이름으로 만들어져 있다면 재정의를 하고, 없다면 만들어라는 식





<<인덱스(Index)>>

- 데이터베이스 테이블에 있는 데이터를 빨리 찾기 위한 용도의 데이터베이스 객체
- 일종의 색인기술 (목차)
- 테이블에 index를 생성하게 되면 index Table을 생성해 관리한다.
- 인덱스는 테이블에 있는 하나 이상의 컬럼으로 만들 수 있다.

- 가장 일반적인 B-tree(Binary Search Tree(이진검색))인덱스는 인덱스 키(인덱스로 만들 테이블의 컬럼 값)와 이 키에 해당하는 컬럼 값을 가진 테이블의 행(줄, ROW)으로 저장된 주소 값으로 구성된다.

- 인덱스는 1개 이상의 컬럼으로 생성할 수 있으며, 최대 32개의 컬럼까지 지정하여 생성할 수 있다.
- 2개 이상의 컬럼으로 생성된 인덱스를 복합 인덱스라고 부른다.
- 테이블에 종속적이다.
- 기본키(주 키 = PRIMARY KEY), 유일키(UNIQUE)를 생성 할 때 자동으로 인덱스가 생성됨
- 되도록 3개 미만의 컬럼으로 만드는게 좋음


<INDEX를 사용해야 할 컬럼> : 
- where절이나 조인 조건에서 자주 사용되는 열에 생성
단, 컬럼이나 값에 대한 가공이 없어야 한다.
예 : 
SUBSTR(DEPTNO, 1, 2) = 10 (X)
DEPTNO = 10 (O)

- 조회결과가 전체행의 5 ~ 15% 정도로 읽어들일 것으로 예상되는 컬럼
단, 5 ~ 15% 라도 데이터가 *너무 많을 경우에는 인덱스를 사용해도 소용이 없을 수 있다.
그런 경우에는 다른 방법으로(페이징처리, 등) 처리를 해주는 것이 좋다.


<INDEX를 사용하지 말아야 할 컬럼> : 
- 테이블에 데이터가 너무 적거나(5%이하) 또는 15%이상의 데이터가 있는 경우
- where절에 자주 사용되지 않는 열은 사용되지 않는다.
- 중복값이 많은 경우
- 테이블이 자주 갱신될 때
- 값에 NULL이 많은 컬럼


<인덱스 생성>
//형식 (= 문법 = SYNTAX)
CREATE INDEX [계정명(= 스키마명).]인덱스명 ON [계정명.] 테이블명((인덱스로 만들)컬럼1, 컬럼2, 컬럼3,....);

**UNIQUE인덱스 생성
반드시 중복값이 없는 컬럼이거나 PRIMARY KEY 제약조건이 걸려있는 컬럼에만 생성가능
//형식
CREATE UNIQUE INDEX [계정명(= 스키마명).]인덱스명 ON [계정명.] 테이블명((인덱스로 만들)컬럼1, 컬럼2, 컬럼3,....);



<인덱스 재생성>
//형식 (= 문법 = SYNTAX)
CREATE INDEX 인덱스명 ON 테이블명((인덱스로 만들)컬럼명, 컬럼명,....);

오라클은 ALTER INDEX 문을 사용해서 인덱스 컬럼 변경 불가.
인덱스의 컬럼을 추가, 제거 또는 순서를 변경하기 위해서는
인덱스를 삭제(DROP)다시 생성(CREATE) 해야 한다.



<인덱스 수정>
- 인덱스명 변경(인덱스명만 변경가능, 컬럼 추가, 삭제, 변경 불가)
//형식 (= 문법 = SYNTAX)
ALTER INDEX 기존인덱스명 RENAME TO 변경인덱스명;
//예 : 
ALTER INDEX PERSON_INDEX_NM_MAIL RENAME TO PERSON_INDEX;



<인덱스 삭제>
- 인덱스컬럼 추가, 삭제, 변경, 제거는 삭제 후 재생성으로 가능
//형식 (= 문법 = SYNTAX)
DROP INDEX 인덱스명;
//예 : 
DROP INDEX PERSON_INDEX;



<인덱스 리빌드>
- 인덱스 속도가 저하되었거나, 깨졌을 경우
//형식 (= 문법 = SYNTAX)
ALTER INDEX 인덱스명 REBUILD;




<<레벨 확인 방법>>
**BLEVEL(Branch level) : 오라클이 index에 접근할 때 몇 단계를 거쳐서 해당 위치를 찾아가는지의 여부를 나타냄
예 : 
SELECT TABLE_NAME, INDEX_NAME, BLEVEL FROM DBA_INDEXES WHERE OWNER = '계정명';




<<시퀀스(SEQUENCE)>>
- 시퀀스는 유일(UNIQUE)한 값을 생성해주는 오라클 객체 (NOCYCLE일 때)
- 시퀀스를 생성하면 기본 키와 같이 순차적으로 증가하는 컬럼을 자동적으로 생성할 수 있게 된다. (INCREMENT값이 양수일 경우)
- SEQUENCE를 생성할 때 값을 지정하지 않으면 1부터 1씩 증가. 
- 즉, 테이블 내의 유일한 숫자를 자동으로 생성하는 자동 번호 방생기라 보면 됨. (NOCYCLE일 때)
- 시퀀스는 테이블에 종속적이지 않다.



<시퀀스 형식>
CREATE SEQUENCE 시퀀스명

--시퀀스명 명명규칙 (권장사항)
- SEQ(SEQUENCE)_[테이블명_]컬럼명
- [테이블명_]컬럼명_SEQ(SEQUENCE)


① [START WITH n] 
② [INCREMENT BY n] 
③ [{MAXVALUE n | NOMAXVALUE}]
④ [{MINVALUE n | NOMINVALUE}]
⑤ [{CYCLE | NOCYCLE}]
⑥ CACHE | NOCACHE



① START WITH : : 디폴트 1부터 시작
시퀀스 번호의 시작값을 지정할 때 사용함. 
예시: 1부터 시작되도록 하려면: START WITH 1

② INCREMENT BY : 디폴트 1씩 증가
연속적인 시퀀스 번호의 증가치를 지정할 때 사용함.
예시: 1씩 증가하는 시퀀스를 생성하려면 : INCREMENT BY 1

③ MAXVALUE n | NOMAXVALUE  : 디폴트 NOMAXVALUE  
미지정시 : 9999999999999999999999999999 자동입력
MAXVALUE :  시퀀스가 가질 수 있는 최대값을 지정할 때 사용. 
NOMAXVALUE :  미지정값을 의미, 9999999999999999999999999999

④ MINVALUE n | NOMINVALUE : 디폴트 NOMINVALUE
MINVALUE 은 시퀀스가 가질수 있는 최소값을 지정할 때 사용. 
NOMINVALUE: 미지정값을 의미, 기본 1이고 최소 -999999999999999999999999999

⑤ CYCLE | NOCYCLE : 디폴트 NOCYCLE 
CYCLE 은 지정된 시퀀스 값이 최대값까지 증가가 완료되게 되면 다시 START WITH 옵션에 지정한 시작 값에서 다시 시퀀스를 시작하도록 한다. NOCYCLE은 증가가 완료되게 되면 에러를 유발한다.

⑥ CACHE OR NOCACHE :NOCACHE 권장, 디폴트 NOCACHE
- CACHE 설정 시 메모리에 시퀀스 값을 미리 할당
- NOCACHE 설정 시 시퀀스값을 메모리에 할당하지 않음. (= CACHE 20과 동일) 

==============================================




//시퀀스를 MAX부터 -1씩 감소하는 예시
CREATE SEQUENCE SEQ_NO
START WITH 5 -- 이 부분은 생략가능.
INCREMENT BY -1
MAXVALUE 5 -- 이 부분은 생략불가, START값이 MAX보다 크면 안됨
NOCACHE; -- 이 부분은 생략가능. 디폴트가 NOCACHE
--CYCLE인 경우는 반드시 MINVALUE가 존재해야 함.


//CACHE값 설정 오류 예시
CREATE SEQUENCE SEQ_NO
INCREMENT BY 2
MAXVALUE 5
CYCLE CACHE 4;
--CYCLE은 CACHE 또는 NOCACHE로 꼭 설정을 해주어야 하며, CACHE값은 1보다 크고 한 사이클 주기(MINVALUE와 MAXVALUE, INCREMENT BY 값까지 체크하여 확인)보다 작거나 같아야 한다.



================================================
<<CURRVAL, NEXTVAL>> : 슈도컬럼(PSEUDO)
- CURRVAL : 현재 값을 반환한다.
- NEXTVAL : 현재 시퀀스값의 다음 값을 반환한다.

- CURRVAL에 새로운 값이 할당되기 위해서는 NEXTVAL로 새로운 값을 생성해야 한다.
- 즉, NEXTVAL로 새로운 값을 생성한 다음에 이 값을 CURRVAL에 대체하게 된다는 이야기이다.



================================================

@ NEXTVAL, CURRVAL을 사용할 수 있는 경우
- SELECT문 (아래 분가능부분 제외)
- INSERT문의 SELECT절, VALUES절
- UPDATE문 SET절
- CREATE문의 서브쿼리



@ NEXTVAL, CURRVAL을 사용할 수 없는 경우
- VIEW의 SELECT절

- DISTINCT 키워드가 있는 SELECT문
- SELECT문의 GROUP BY, HAVING, ORDER BY 절
- SELECT, DELETE, UPDATE문의 WHERE 조건

- CREATE TABLE, ALTER TABLE의 DEFAULT



//USER_SEQUENCES 데이터 딕셔너리로 시퀀스 확인하고 필요없는 것 제거할 것
SELECT * FROM USER_SEQUENCES;





//
//30
//필기
//




<<DCL(Data Control Language, 데이터 제어어)>>
- 데이터의 보안, 무결성, 회복, 병행 수행 제어, 등을 정의하는데 사용하는 언어
**TCL포함
- GRANT : 데이터베이스 사용자에게 사용 권한을 부여
- REVOKE : 사용자계정의 권한을 회수



<*권한 관리>

- 사용자에 의해 사용되는 권한
CREATE SESSION : 데이터베이스에 연결할 수 있는 권한, USER로 연결(접속)할 수 있는 권한
CREATE TABLE : 테이블을 생성할 수 있는 권한
CREATE VIEW : 뷰를 생성할 수 있는 권한
CREATE SEQUENCE : 시퀀스를 생성할 수 있는 권한
CREATE PROCEDURE : 함수를 생성할 수 있는 권한

- CONNECT 롤 :
사용자가 데이터베이스에 접속 가능하도록 가장 기본적인 시스템 권한을 묶어 놓았다.
CREATE TABLE(접근권한), CREATE SEQUENCE, CREATE CLUSTER, CREATE SESSION, ALTER SESSION, CREATE SYNONYM, CREATE DATABASE LINK

- RESOURCE 롤 : 
유저를 생성하면 일반적으로 CONNECT, RESOURCE 롤을 부여 한다.
사용자가 객체를 생성할 수 있도록 시스템 권한을 묶어 놓았다.
CREATE TABLE(자원(생성)권한), CREATE SEQUENCE, CREATE CLUSTER, CREATE TRIGGER, CREATE PROCEDURE



<현재 사용자의 시스템 권한 정보 확인>
SELECT * FROM SESSION_PRIVS;



=====================================================


1. 선택적 권한부여 : 
DBA권한을 가진 USER가 자신의 계정에 접근하는 USER의 권한을 선택하여 부여할 수 있다.
GRANT SELECT ON [스키마명(계정명)].[TABLE명] TO [USER명];
GRANT INSERT ON [스키마명(계정명)].[TABLE명] TO [USER명];
GRANT DELETE ON [스키마명(계정명)].[TABLE명] TO [USER명];
GRANT UPDATE ON [스키마명(계정명)].[TABLE명] TO [USER명];

--또는
GRANT SELECT, INSERT, DELETE, UPDATE ON [TABLE명] TO [USER명];
GRANT ALL ON [TABLE명] TO [USER명];
=====================================================


2. 선택적 권한취소 : 
REVOKE SELECT ON [스키마명(계정명)].[TABLE명] FROM [USER명];
REVOKE INSERT ON [스키마명(계정명)].[TABLE명] FROM [USER명];
REVOKE DELETE ON [스키마명(계정명)].[TABLE명] FROM [USER명];
REVOKE UPDATE ON [스키마명(계정명)].[TABLE명] FROM [USER명];

--또는
REVOKE SELECT, INSERT, DELETE, UPDATE ON [TABLE명] FROM [USER명];
REVOKE ALL ON [TABLE명] FROM [USER명];
=====================================================


다른 계정에 SELECT, INSERT, DELETE, UPDATE 모든(ALL) 권한 부여
GRANT ALL ON [TABLE명] TO [USER명];


다른 계정에 모든 테이블에 대한 SELECT 권한 부여
GRANT SELECT ANY TABLE TO [USER];


--ALL과 ANY는 같이 사용할 수 없다
--ALL은 ON이 필요하고 ANY는 ON이 없어야해서 같이 사용 안됨
GRANT ALL ON ANY TABLE TO ORAUSER; (X)

=====================================================




<<시노님(SYNONYM : 동의어 - 테이블에 대한 별칭 부여)>>
- DBA권한이 부여된 계정만 생성 가능.
- 비공개동의어(PRIVATE SYNONYM), 공개동의어(PUBLIC SYNONYM)이 있다.


<비공개동의어(PRIVATE SYNONYM)> : 
만든 계정에서만 접근 가능하며, 다른계정은 권한을 부여 받아야 접근할 수 있다.
(단, DBA권한 계정은 모두 접근 가능)
비공개동의어는 비공개시노님은 접근권한이 부여된 계정이더라도 접근할 때 반드시 계정명.으로 접근해야 한다.

생성형식 : 
CREATE OR REPLACE [PRIVATE-디폴트,생략가능|PUBLIC-생략불가] SYNONYM [스키마명.]시노님명 FOR [스키마명.]객체명;
**객체명에는 테이블명, 뷰명, 프로시저명, 함수명, 패키지명, 시퀀스명, 등이 올 수 있다.
**시노님은 별도의 수정구문이 없으므로 삭제 후 재생성을 해야한다.




<[오라클]오라클계정 비밀번호 만료기간 해제 및 변경>

비밀번호 유효기간은 기본값이 180일로 설정 되어있어 유효기간이 지나면 자동만료되어 접속할 수 없게 된다.

오라클 계정 비밀번호 만료일이 지나면, [oracle : the password has expired] 라는 메세지와 함께 접속할 수 없다.


<비밀번호 만료기간 해제하기>

1. 관리자계정으로 접속
splplus / "as sysdba"

2. 비밀번호 유효기간 확인
SQL > select * from dba_profiles where profile = 'DEFAULT';

2-1. 비밀번호 만료기간만 확인해보면, 180으로 설정되어 있는 것을 볼 수 있다.
SQL > select * from dba_profiles where resource_name = 'PASSWORD_LIFE_TIME';

3. DEFAULT 비밀번호 만료기간 unlimited로 변경하기
SQL > alter profile default limit password_life_time unlimited;

4. 다시 한번 비밀번호 만료기간 확인해보기
비밀번호 만료기간 해제 완료


만약, 비밀번호가 만료되어 접속이 안될 때, 해결방법은 
비밀번호 유효기간을 바꾸기전에 계정의 락 해체 후에 비밀번호를 변경해줘야 한다.


<계정 락 해체하기>
SQL > alter user 계정명 account unlock;

<비밀번호 변경하기>
SQL > alter user 계정명 identified by 새비밀번호;




ORACLE SID(데이터베이스) 선택 변경 방법

WINDOWS 편집창에서 실행 할 것 (SQL편집창에서 실행하면 안됨)
C:\Users\hi>set oracle_sid=SID명입력하기
C:\Users\hi>SQLPLUS 사용자계정명/비밀번호[@SID명]




<<의사 컬럼 (슈도컬럼 = PSEUDO)>>

<ROWNUM> 키워드
- 인덱스에서 저장하는 ROWID(행주소)값이기도 함.
- 저장된 행 순서대로 자동으로 순번을 부여함.
- 단순쿼리인 경우에는 where절에만 사용 가능.
단, 서브쿼리 사용 시 select절에도 표현할 수 있다.
- 페이징처리를 하려면 서브쿼리를 이용하여 할 수 있다.
*페이징처리 : 한 번에 보여지는 수를 조정하는 것
- order by절 이용 시 꼭 서브쿼리에서 사용할 것

// 형식 : 
- ROWNUM < 값
- ROWNUM <= 값
*값은 양의 정수로 표현

--단순쿼리 시
SELECT * FROM CUSTOMERS WHERE ROWNUM <= 1000 AND CUST_GENDER = 'M';

--서브쿼리 시
SELECT ROWNUM RN, C.* 
FROM (SELECT * FROM CUSTOMERS WHERE CUST_GENDER = 'M') C
WHERE ROWNUM <= 500;

--**페이징 쿼리
페이징 처리시에는 꼭 별칭을 지정해 주어야만 제대로 인식될 수 있다.
SELECT * FROM (SELECT ROWNUM RN, C2.* FROM CUSTOMERS C2 WHRER CUST_GENDER = 'M')
WHERE RN BETWEEN 10 AND 13;

SELECT * FROM (SELECT ROWNUM RN, C2.* FROM CUSTOMERS C2 WHRER CUST_GENDER = 'M')
WHERE RN >= 50 AND RN <= 100;




<<MERGE절>>
조건에 의해 한꺼번에 추가(INSERT), 갱신(UPDATE), 삭제(DELETE) 할 수 있는 명령문 ON절에 있는 조건에 UPDATE 할 컬럼이 들어가면 안됨. 오류 발생

형식 : 
MERGE INTO 변경을원하는테이블명1 [별칭]	--서브쿼리가 와도 된다.
USING 데이터를가져올테이블명2 [별칭]	--뷰, 테이블, 서브쿼리 등 가능
ON (테이블1과 테이블2를 엮을 조건)		--이너조인과 동일하게 기술
-ㄴ필수--

[
WHEN MATCHED THEN		--이 절에는 반드시 UPDATE문이 와야 한다.
(ON절 조건이 일치하면)
UPDATE SET 테이블1의컬럼1 = 테이블2의컬림1, 테이블1의컬럼2 = 테이블2의컬럼2,....
[DELETE WHERE 조건		**반드시 UPDATE절과 같이 써야 한다.]
]


[
WHEN NOT MATCHED THEN		--이 절에는 INSERT문이 올 수 한다.
(ON절 조건이 일치하지 않으면)
INSERT (테이블1의컬럼1,테이블1의컬럼2,....) VALUES (테이블2의컬럼1, 테이블2의컬럼2,...);
]




CREATE TABLE EMP01 AS SELECT * FROM EMP01;

MERGE INTO EMP01 A
USING (SELECT EMPNO, SAL, JOB FROM EMP WHERE DEPTNO = 10) B
ON (A.EMPNO = B.EMPNO)
WHEN MATCHED THEN
UPDATE SET A.SAL = SAL + SAL * 0.01
WHEN NOT MATCHED THEN
INSERT (A.EMPNO, SAL, JOB) VALUES (B.EMPNO, B.SAL, B.JOB);





//
//31
//필기
//




<<집합 연산자>>
집합연산자 : UNION, UNION ALL-합집합 / INTERSECT-교집합 / MINUS-차집합

집합연산자의 제한 조건 : 
- **두 테이블의 컬럼 개수와 자료형, 나열순서가 같아야 한다.

- ORDER BY 절은 모든 쿼리문을 다 기술한 뒤 맨 마지막에 한 번만 기술가능하다.
(단, ORDER BY 절을 쓸 때는 처음에 기술한 테이블이 기준이 되기 때문에 처음 기술한 테이블의 컬럼으로만 정렬 가능)
- LOB(BLOB, CLOB, BFILE)자료형, LONG자료형에는 사용할 수 없다.


1. UNION : 합집합
- 두 개의 테이블의 데이터를 모두 포함한 결과를 반환함.
- 중복을 허용하지 않는다. 중복값은 1개만 표현함
예: 
SELECT DEPTNO, ENAME FROM EMP *UNION SELECT DEPTNO, DNAME FROM DEPT;


1-2. UNION ALL : 합집합
- UNION과 거의 다 동일하지만 중복을 허용하여 모두 출력한다.


2. INTERSECT : 교집합
- 두 개의 테이블의 데이터 중 공통된 항목만 반환함.
- 중복을 허용하지 않는다.


3. MINUS : 차집합
- 두 개의 테이블의 데이터 중 공통된 항목을 제외한 데이터만 반환하는데,
단, 먼저 처리된 테이블의 항목만 반환한다. 나중에 처리된 테이블의 결과는 제외.
- 중복을 허용하지 않는다.




<<PL/SQL (ORACLE'S PROCEDURAL LANGUAGE EXTENSION TO SQL)>>
1. 절차적 언어
- 절차적 언어란, 개발자가 처리 절차(처리순서, 처리방법)를 처음부터 끝까지 정해주어야 하는 언어.

2. 비절차적 언어
- 비절차적 언어란, 개발자가 처리절차를 지정하지 않고 원하는 결과를 정의하여 요청하는 언어.


<PL/SQL>
- 오라클 자체에 내장되어 있는 절차적 언어(Procedural Language)로서,
SQL의 비절차적 언어의 단점을 보완, 확장한 언어

- **SQL 문장에서 변수 정의, 조건(IF), 반복(LOOP, WHILE, FOR) 처리 등을 지원

- **블록(Block) : PL/SQL 프로그램의 기본 단위

- 데이터에 대한 조작을 SQL만으로 처리하는데 한계가 있는 경우, 
DB안에서 데이터 값에 대한 처리를 하고 싶은 경우(함수, 프로시저, 트리거 등등) 사용.


<구성> : 
- DECLARE(선언부) : 기술여부는 선택, 실행에 사용 될 변수/상수/커서 등을 선언
- BEGIN(실행부) ~ END : 기술여부는 필수, 조건문/반복문/SELECT/DML/함수 등을 정의
- EXCEPTION(예외 처리부) : 기술여부는 선택, PL/SQL 실행 도중 발생하는 오류(예외 상황)를 해결하는 문장 서술


<PL/SQL 작성 주의사항>
1. PL/SQL블록을 구성하는 DECLARE, BEGIN ~ END, EXCEPTION 키워드에는 세미콜론(;)을 사용하지 않는다.
(단 BEGIN문 안에 기술하는 SQL명령문에는 세미콜론을 사용해야 한다.)

2. PL/SQL블록의 각 부분에서 실행해야 하는 문장 끝에는 세미콜론(;)을 사용.
ex) DBMS_OUTPUT.PUT_LINE('HELLO, PL/SQL !');

3. SQL에서와 마찬가지로 PL/SQL 내부에서도 주석 사용 가능
한 줄 주석 : --
여러 줄 주석 : /*주석내용*/

4. PL/SQL문 작성을 마치고 실행하기 위해 마지막에 슬래시(/)를 사용(SQLDevelper에서는 생략 가능)
**마지막에 슬래시(/)는 PL/SQL문 작성이 끝났다는 의미와 실행하라는 의미를 가지고 있음.

5. 선언 조건(권장사항)
변수 : 변수앞에 v를 붙여준다. variable의 약자
상수 : 상수앞에 c를 붙여준다. constant의 약자
매개변수 : 매개변수앞에 p를 붙여준다. parameter의 약자



- <익명블록 (ANONYMOUS BLOCK)> : 
이름 없이 선언된 PL/SQL문을 익명블록이라 함.

//형식 : 
[
DECLARE   --선언부 (DECLARE SECTION)
   변수나 상수, 커서를 선언
]
BEGIN   --실행부 (EXECUTABLE SECTION)
   SQL문
   제어문, 반복문, 출력문
   커서 사용
   [EXCEPTION   --예외 처리부 (EXCEPTION SECTION)]

END;
/




--DBMS_OUTPUT : java의 System.out객체와 유사

--SET SERVEROUTPUT ON : 
DBMS_OUTPUT이 정상 작동하도록 설정을 ON하는 기능(출력 콘솔창을 킨다는 의미)
SET SERVEROUTPUT ON을 기술해주지 않으면 출력결과를 확인하기가 어렵다.
단. sqldeveloper에서는 생략가능




DBMS_OUTPUT 패키지는 문자열 출력을 위해 3가지 프로시저를 지원함
PUT_LINE : 문자열을 출력한 후 다음 라인으로 이동.
PUT : 문자열을 출력한 후 대기. 반드시 다음 줄로 넘어갈 수 있는 무언가가 지정되어 있어야 한다.
NEW_LINE : 다음 라인으로 이동. 매개인자 값을 넣으면 안됨.



<*변수>
- 테이블의 컬럼 정의와 구조가 동일하다.
- 변수를 초기화 하지 않고 정의만 한 경우는 해당 변수의 자료형에 상관없이 NULL값으로 지정된다.
- 변수 정의 시 NOT NULL 이나 CONSTANT(상수) 로 정의하여 변수의 데이터에 일부 제약(Constraint) 사항을 정의할 수도 있다.

- 형식 : 
변수명 자료형(데이터타입) := 초기값;
변수명 자료형(데이터타입) [NOT NULL] [:= 초기값];
변수명 자료형(데이터타입);



<*  :=	PL/SQL에서의 대입연산자 >



<상수>
- 한 번 값을 할당 받으면 변하지 않는 수
- 꼭 선언과 동시에 초기화도 해주어야 한다.

- 형식 : 
상수명 CONSTANT 자료형(데이터타입) := 상수값;
*꼭 CONSTANT 키워드를 붙여야 한다.



<연산자>
** : 제곱연산자 예) 2**3 -> 2의 3승

+값, -값 : 부호연산자. 양수, 음수 식별연산자

*, / : 산술연산자 중 곱셈, 나눗셈

+, -, || : 산술연산자 중 덧셈, 뺄셈 및 문자열 연결 연산자

=, <, >, <=, >=, <>, !=, ~=, \^=, IS NULL, LIKE, BETWEEN~AND, IN : 비교연산자

NOT : 논리연산자, 부정을 의미
	NOT true : false
	NOT false : true
	NOT null : null

AND : 논리연산자, 교집합을 의미 
	true AND true : true
	true AND false : false
	false AND false : false
	true AND null : null
	false AND null : false
	null AND null : null

OR : 논리연산자, 합집합을 의미 
	true OR true : true
	true OR false : true
	false OR false : false
	true OR null : true
	false OR null : null
	null OR null : null



DECLARE
VEMPNO NUMBER(4);
VENAME VARCHAR2(10);
BEGIN 
VEMPNO := 7788;
VENAME := 'SCOTT';
DBMS_OUTPUT.PUT_LINE('사번 / 이름');
DBMS_OUTPUT.PUT_LINE('---------');
DBMS_OUTPUT.PUT_LINE(VEMPNO || '/' || VENAME);
END;
/




<<데이터 타입>>

- <스칼라 타입> : 
숫자(NUMBER), 문자(CHAR, VARCHAR2), 날짜(DATE, TIMESTAMP), BOOLEAN 등
- 스칼라 변수 : SQL자료형과 비슷하게 선언하는 변수를 말함.


-<레퍼런스 타입(= 참조자료형)> : 
- 레퍼런스 변수 : DB 테이블의 특정 컬럼으로 변수 타입을 지정할 때 사용
- 테이블에서 컬럼의 자료형이 반경되더라도, PL/SQL에서의 변수 선언부분을 수정할 필요가 없다는 장점이 있다.

- 형식 : 
   테이블이름.필드명%TYPE : 컬럼 타입 선언, 컬럼(열, 칸, 필드, 항목, 속성) 단위
   예) EMP.EMPNO%TYPE -> NUMBER(4,0)

   테이블이름%ROWTYPE : 레코드 타입 선언, 레코드(행, 줄, 로우) 단위
   예) EMP%ROWTYPE -> 
    /EMPNO/         /ENAME/	      /JOB/         /MGR/    /HIREDATE/   /SAL/          /COMM/        /DEPTNO/
NUMBER(4,0) VARCHAR2(10) VARCHAR2(9) NUMBER(4,0)  DATE  NUMBER(7,2) NUMBER(7,2) NUMBER(2,0)	
				
			
			
				
			
DECLARE
--테이블의 컬럼의 데이터타입과 일치시켜 주는 것이 좋다. 에러 예방
--스칼라 변수 선언
VEMPNO NUMBER(4);
VENAME VARCHAR2(10);
VDEPTNO NUMBER(2);
VDNAME VARCHAR2(14);
BEGIN
--테이블 안의 데이터를 받아오는 경우 select절 안에 into를 이용한다.
--select절 컬럼의 데이터타입, 개수, 순서와
--INTO절의 변수의 데이터타입, 개수, 순서가 일치해야 한다.
--select절의 데이터는 INTO절을 통해 해당 변수를 초기화 해줘야 하기 때문에 
--반드시 한 줄의 데이터만 가져오는 쿼리문이여야 한다.

SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME
INTO VEMPNO, VENAME, VDEPTNO, VDNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND E.ENAME = 'SMITH';

DBMS_OUTPUT.PUT_LINE('사번 / 이름 / 부서번호 / 부서명');
DBMS_OUTPUT.PUT_LINE('---------------------------------');
DBMS_OUTPUT.PUT_LINE(VEMPNO || ' / ' || VENAME || ' / ' || VDEPTNO || ' / ' || VDNAME);
END;
/			
			



<IF~ ELSIF~ ELSE조건문>
- 형식 : 
IF 조건1(condition1) THEN
   실행문1(statement1);
[
ELSIF 조건2 THEN
   실행문2;
ELSE
   실행문3;
]
END IF;




<ORACLE에서의 BOOLEAN자료형>
값 : TRUE, FALSE, NULL 값을 가질 수 있다. (대소문자 안가림)
다른 자료형은 DBMS_OUTPUT의 출력문을 통해 출력 가능하지만 
BOOLEAN자료형 값은 DBMS_OUTPUT의 출력문으로 바로 값을 출력할 수 없다.(오류)





//
//32
//필기
//





<<반복문 (LOOP)>>

<BASIC LOOP 기본 반복문>
형식 : 
LOOP

반복으로 실행할 코드;
...
(*필수) 탈출하는 코드;
END LOOP;




<FOR LOOP>
형식 : 
FOR 인덱스명 IN [REVERSE(역순)] 시작값..종료값 LOOP --(시작값과 종료값 사이 점두개 기술 필수)

반복으로 실행할 코드;
...
[탈출하는 코드;]
END LOOP;


**인덱스명 : 
선언할 필요가 없다.
변수처럼 값을 직접 대입받아서 변경하거나 할 수 없다.
IN 뒤의 범위의 값을 자동으로 하나씩 받아서 값을 가지게 되는 변수이다.




<WHILE LOOP>
형식 : 
WHILE 조건 LOOP

반복으로 실행할 코드;
...
탈출하는 코드;
END LOOP;





<CONTINUE> : 
LOOP 머리로 돌아가라




<라벨>
<<라벨명>> --라벨을 붙일 수 있다.
...
...
GOTO 라벨명; --라벨로 돌아가기, 대소문자 구분 안함.




<<커서 (Cursor)>>
- SQL문을 처리한 결과를 담고 있는 영역(메모리영역)을 가리키는 일종의 포인터
- 처리 결과가 여러 개의 행으로 구해지는 SELECT문을 처리할 때 이용.
- 커서의 사이클 : 열기(OPEN) - 패치(FETCH) - 닫기(CLOSE)
- FETCH문은 결과셋(결과테이블)에서 로우(행=레코드) 단위로 데이터를 읽어들인다.
- FETCH 후에 CURSOR는 결과셋에서 다음 행으로 이동한다.

- 커서의 상태 
   -- %FOUND : 커서 영역에 FETCH 되지 않은 자료가 있다면 TRUE
   -- %ONTFOUND : 커서 영역의 데이터가 모두 FETCH 되었다면 TRUE
   -- %ISOPEN : 커서가 OPEN 된 상태이면 TRUE
	         묵시적커서는 OPEN 상태 인식이 안된다. 따라서 늘 FALSE
   -- %ROWCOUNT : 커서가 얻어 온 레코드의 개수
**묵시적커서 : 커서를 명시적으로 선언하지 않아도 자동으로 실행되는 커서(대표적 : SQL실행문)
**명시적커서 : DECLARE부에 선언하는 커서들
SQL%ROWCOUNT : 해당 코드가 기술되기 바로 직전에 실행된 SQL명령에서 처리된 묵지적커서의 행수를 반환함.
커서명%ROWCOUNT : 해당 커서의 전체 행 수를 반환함.

- 형식 : 
DECLARE
CURSOR 커서이름 IS SELECT쿼리문; --명시적커서
BEGIN
OPEN 커서이름 [(매개변수, ...)];
FETCH 커서이름, INTO 변수이름;
CLOSE 커서이름;
END;
/



<<CURSOR와 FOR LOOP>>
- 반복할 때마다 CURSOR를 OPEN 한 후, 행(레코드)을 인출(FETCH)한다.
- 모든 행이 처리되면 자동으로 CURSOR가 CLOSE된다.
- REVERSE처리를 할 수 없다.

- 형식 : 
FOR 레코드 IN 커서명[(매개변수, ...)]
LOOP
실행문;
...
END LOOP;




<<동적 SQL>>
- 고정된 SQL이 아닌 변경 가능한 쿼리를 말한다.
- 사용될 SQL문이 실행시에 결정된다.
- 종류 : 
원시 동적 SQL(NDS - Native Dynamic SQL)방식, DBMS Dynamic SQL방식이 있음.

사용을 하는 이유
- 컴파일 시 SQL문이 확정되지 않을 때
- PL/SQL 블록 상에서 DDL문을 사용해야 할 때

NDS(Native Dynamic SQL) : 원시 동적 SQL
- 동적 SQL한 종류.
- EXECUTE IMMEDIATE ~ INTO 문 사용

- 형식 : 
EXECUTE IMMEDIATE sql문자열 INTO 담을변수1, 담을변수2, ...
[USING sql문자열에서 사용한 변수에 대응되는 바인드변수1, 바인드변수2, ...];
**sql문자열은 SQL쿼리문을 담기 때문에 자료형의 사이즈를 좀 넉넉하게 해준다.

**실행 순서 : sql문자열 -> [USING절] -> EXECUTE IMMEDIATE -> INTO절




--SQL쿼리문을 변수에 담는다
--V_SQL변수가 VARCHAR2이므로 안의 SMITH가 문자열이라는 것을 인식하도록 하기 위해서는
--''값''(작은따옴표 2개)을 사용해야 한다. 큰따옴표가 아님.

--바인드 변수 사용 : 연결해주는 변수를 바인드라고 함.
--SQL쿼리문에 변수를 설정하여 해당 변수에 대응하는 값을 연결해주는 방식
--여러 SQL안의 값이 변경되어도 구문을 변경해줄 필요가 없다.
--SQL쿼리문을 바인드 변수로 처리
--SQL쿼리문 안의 바인드 변수는 꼭 [:변수명] 형식으로 기술해주어야 한다.




//
//33
//필기
//



혹시라도 이전 버전이나 낮은 버전 사용하는 경우 DBA권한을 부여 받은 계정에서라도 PL/SQL에서 CREATE TABLE명령문 실행 시
에러가 발생되는 경우 (PRIVILLAGE...) DBA권한을 가진 계정이더라도
다시 한 번 CREATE TABLE권한을 부여해주어야 한다.
- GRENT CREATE TABLE TO TEST;



-------------------------------------------------------------------------
<<함수 (FUNCTION)>>
오라클에서 제공하고 있는 내장함수(= 빌트인함수)처럼
매개변수를 받아 뭔가를 처리해 그 결과를 반환하는 데이터베이스 객체이며,
사용자 정의 함수를 말함.
*****꼭 반환값이 있어야 한다. => 리턴문, 리턴값이 존재

//형식 :
CREATE OR REPLACE FUNCTION 함수이름 (매개변수1, 매개변수2, ...)
RETURN 데이터타입
IS[또는 AS]
변수, 상수 등 선언
BEGIN
실행부
...
RETURN 반환값;
[EXCEPTION]
END [함수이름];


//호출문형식 : 
<매개변수가 없는 함수 호출>
함수명 혹은 함수명()

<매개변수가 있는 함수 호출>
함수명(매개변수1, 매개변수2, ...)


--함수제거 : 
DROP FUNCTION 함수명;

-------------------------------------------------------------------------


- 일반 컬렉션자료형은 동일한 자료형으로만 데이터를 가질 수 있기 때문에
자료형이 다른 타입의 중첩테이블 형식을 만드려면 레코드유형으로 자료형을 갖는 
OBJECT자료형으로 먼저 만들어주어야 한다.
- TYPE 생성시에는 제약조건을 넣을 수 없다.
- 반드시 마지막에 /기호를 넣어주어야 한다. 안 넣을 경우 에러 남.
- 유형 변경 시 반드시 하위 유형이 제거된 후에 변경해야 한다.
- OBJECT자료형을 갖는 사용자 자료형 만들기, 자료형명 : DEPT_TYPE (리턴타입)
- 자료형으로 레퍼런스타입은 불가능, 반드시 스칼라타입으로 기술

CREATE OR REPLACE TYPE DEPT_TYPE AS OBJECT (
DEPTNO NUMBER(2),
DNAME VARCHAR2(14),
LOC VARCHAR2(13)
);
/

TABLE TYPE 객체 생성
- 함수에서 반환 가능한 테이블타입으로 오브젝트 자료형 재정의

CREATE OR REPLACE TYPE DEPT_TABLE AS TABLE OF DEPT_TYPE;
-------------------------------------------------------------------------
_TYPE생성 -> 상위
_TABLE생성-> 하위
-------------------------------------------------------------------------




<<프로시저>>
반환값이 없는 프로그램. 
특정 연산을 수행하기만 함.
- 테이블의 갱신이나 다른 테이블에 데이터를 백업하거나 하는 경우 등 이용한다.


<저장 프로시저 (Stored Procedure)>
- 자주 사용되는 쿼리문을 모듈화시켜서 필요할 때마다 호출하여 사용하는 것
- 형식 :
CREATE OR REPLACE PROCEDURE 프로시저명[(P1 [IN(디폴트)/OUT/INOUT] 데이터타입 := 값, ...)]
IS [또는 AS] 
변수, 상수 등 선언
BEGIN
실행문;
...
[EXCEPTION
예외처리문;]
END [프로시저명];
/


<키포인트>
-IN 매개변수는 참조만 가능하며 값을 할당 할 수 없다.
-OUT 매개변수에 값을 전달할 수는 있지만 의미는 없다.
-IN OUT 매개변수는 값 참조 및 전달이 가능하다.
-OUT, IN OUT 매개변수에는 디폴트값을 설정 할 수 없다.

IN 매개변수에는 변수나 상수, 각 데이터 유형에 따른 값을 전달 할 수 있지만
OUT, IN OUT 매개변수는 전달 할 때 반드시 변수 형태로 값을 넘겨줘야 한다.
***OUT키워드가 들어간 매개변수는 실제값으로 호출 못함. 기본값 설정 안됨.


--매개변수 개수가 많아서 인자값이 어떤 변수에 바인딩되는지 잘 모르겠을 때,
--프로시저의 매개변수명과 동일하게 해주어야 하며, 순서는 바뀌어도 상관없다.



--IN OUT 명시 없으면 디폴트는 IN
--매개변수에 초기값이 대입되어 있을 경우, 호출문에 값이 없으면 초기값으로 대입됨.
--,(콤마)를 쓰지 않아도 되는 값까지



--OUT 매개변수
--프로시저 실행 시점에 OUT 매개변수를 변수 형태를 전달하고, 프로시저 실행부에서 이 매개변수에 특정값을 할당한다.
--실행이 끝나면 전달한 변수를 참조해 값을 가져올 수 있다. 



--IN OUT 매개변수
입력과 동시에 출력용으로 사용할 수 있다.
프로시저 실행시 OUT 매개변수에 전달할 변수에 값을 할당해서 넘겨줄 수 있지만 의미없다.
왜냐하면 OUT 매개변수는 프로시저가 성공적으로 실행을 완료할 때까지 값이 할당되지 않기 때문이다.
그러므로 매개변수에 값을 전달해서 사용한 다음 다시 이 매개변수에 값을 받아와 참조하고 싶다면 IN OUT 매개변수를 이용해야 한다.





-------------------------------------------------------------------------
//
//34
//필기
//




<<RETURN문>>
함수에서는 일정한 연산을 수행하고 결과 값을 반환하는 역할을 했지만,
프로시저에서는 RETURN문을 만나면 이후 로직을 수행하지 않고 프로시저를 빠져나간다.





<<예외처리>>
예측 가능한 에러상황을 시스템이 정상 종료되도록 처리하는 것

구체적인 예외명을 알 수 없을 때 : OTHERS를 사용한다. (자바의 EXCEPTION클래스와 유사)
OTHERS는 오라클 시스템에서 PL/SQL 코드 상에서 발생한 런타임 예외를 자동으로 잡아준다.
--오라클에서 제공하는 빌트인 함수 (언어 설계 광정에서 미리 만들어진 함수)

SQLCODE : 실행부에서 발생한 예외에 해당하는 코드를 반환한다.
예) BY ZERO에러 : '-1476'을 반환, 에러가 없으면 0을 반환

SQLERRM : 발생한 예외에 대한 오류 메시지를 반환한다.
매개변수로 예외코드 값을 받는데, 매개변수를 넘기지 않으면
디폴트로 SQLCODE가 반환한 예외코드 값과 연관된 예외 메시지를 반환한다.

DBMS_UTILITY : 좀 더 세부적인 예외 정보제공.
예) DBMS_UTILITY.FORMAT_ERROR_BACKTRACE 함수 : 몇 번째 줄에서 예외가 발생했는지 알려줌.



//형식 : CASE문과 유사
EXCEPTION
WHEN 예외명1 THEN 예외처리 구문1
WHEN 예외명2 THEN 예외처리 구문2
...
WHEN OTHERS THEN 예외처리 구문N;

===========================
미리 정의된 예외 종류들
ACCESS_INTO_NULL : (ORA-06530) 객체가 초기화되지 않은 상태에서 사용 시
CASE_NOT_FOUND : (ORA-06592) CASE문 사용시 구문 오류
CURSOR_ALREADY_OPEN : (ORA-06511) 커서가 OPEN상태에서 재OPEN 시도 시

INVALID_CUTSOR : (ORA-01001) 존재하지 않는 커서를 참조
INVALID_NUMBER : (ORA-01722) 문자를 숫자로 변환 실패 할 경우

NO_DATA_FOUND : (ORA-01403) SELECT INTO절 시 데이터가 한 건도 없을 경우
TOO_MANY_ROWS : (ORA-01422) SELECT INTO절 시 결과가 2개 이상인 경우

VALUE_ERROR : (ORA-06502) 수치 또는 값 오류
ZERO_DIVIDE : (ORA-01476) 젯수가 0일 때 오류





<<트리거(trigger)>>
이벤트가 발생하면 데이터베이스에 의해 자동으로 수행되는 명명 블록이다.
COMMIT, ROLLBACK, SAVEPOINT문을 사용 할 수 없다.
트리거의 주요 사용 목적은 테이블 데이터의 무결성 보장, 데이터베이스 관리의 자동화, 등 이라고 할 수 있다.

단순 DML트리거
- DML이벤트에 의해 수행되는 트리거를 말함.
- 테이블과 뷰에 종속되어 있으며, 대상 객체를 삭제하면 함께 삭제된다.
- 단일 타이밍 포인트(TIMING POINT)를 지정한다.
- DML이벤트 : INSERT, UPDATE, DELETE



//형식 : 
CREATE [OR REPLACE] TRIGGER [스키마.]트리거명
{BEFORE 또는 AFTER} DML이벤트[ OR DML이벤트 OR DML이벤트] ON [스키마명.]{테이블명 또는 뷰명}
[REFERENCING] --상관명 별칭 사용
[FOR EACH ROW] --행 단위로 수행하는 경우 기술
[FOLLOWS] --트리거 순서 정하기
[WHEN (조건)]
[DECLARE 선언부]
BEGIN
실행문, 출력문, 조건.제어문 등등;
...
[EXCEPTION 예외처리부]
END [트리거명];
/




--트리거 생성시 주의할 점
최대 코드 용량은 32KB를 넘을 수 없다.
순환트리거링, 재귀 트리거링이 되지 않도록 주의해야 한다.




--테이블에 종속 된 전체 트리거 활성화/비활성화 하기
ALTER TABLE [스키마명.]테이블명 {ENABLE 또는 DISABLE} ALL TRIGGER;


--해당 트리거 하나만 활성화/비활성화 하기
ALTER TRIGGER 트리거명 {ENABLE 또는 DISABLE};




<행단위 DML트리거>
:OLD, :NEW 상관명으로 이용하여 변경 전, 후 값을 참조 할 수 있다.
- 단, INSERT문의 :OLD값과 DELETE문의 :NEW값은 무조건 NULL을 반환한다.
==============================
<DML>		<:OLD>		<:NEW>
==============================
INSERT		NULL		삽입 값
-----------------------------------------------------
DELETE		삭제전 값		NULL
-----------------------------------------------------
UPDATE		갱신전 값		갱신후 값
==============================




<PRAGMA AUTONOMOUS_TRANSACTION;>

TRIGGER에 연결 된 프로시저나 함수에 트랜잭션 작업이 있어서 영향을 받게 되는 경우
해당 트랜잭션 작업에 영향을 받지 않도록 독립적으로 실행을 해주라는 명령임.






<<JDBC(Java DataBase Connection)>>
자바와 데이터베이스를 연동하는 기술.
**오라클 연동에 관련 된 인터페이스들은 java.sql패키지 안에 들어있다.
java.sql.Connection : 데이터베이스의 계정과 비번, url정보를 담고 있는 객체
java.sql.Statement : 데이터베이스의 SQL명령을 감을 수 있는 객체
java.sql.PreparedStatement : 데이터베이스의 SQL명령을 감을 수 있는 객체
java.sql.ResultSet : SELECT 명령을 실행 후 가져오는 데이터의 결과 집합(레코드들의 묶음 => 인스턴스들)을 가리키고 있는 오라클의 커서와 동일한 기능을 가진 객체


--데이터베이스 연결에 필요한 드라이버 준비 및 설치

1. 파일 준비 
(C:\oraclexe\app\oracle\product\11.2.0\server\jdbc\lib)
11g => ojdbc6.jar
10g => ojdbc5.jar


2. 자바프로젝트에 1번의 jar파일을 추가하기
프로젝트명 선택 후 마우스 우클릭 -> Build Path...선택 -> Configure Build Path...선택 -> Libraries 탭 선택 -> Module Path 선택 후 오른쪽의 [Add External JARs...] 선택 -> Apply and Close 


3. 드라이버 설치
(소스코드에 기술)
Class.forName('패키지경로포함.클래스명까지기술');
=> Class.forName("oracle.jdbc.driver.OracleDriver");
=> (ojdbc6.jar)자르파일 압축해제 후 oracle안에 jdbc안에 driver안에 OracleDriver.Class파일


4. Connection 객체 얻어오기 (필요한 사항(문자열값으로): url, username, password)
**username = "오라클의 사용자 계정명" => "test 또는 TEST"
**password = "1111"
**url => 형식 : jdbc:데이터베이스종류:[오라클인경우는드라이버버전까지:]@호스트명:포트번호:전역데이터베이스명(SID);
=> "jdbc:oracle:thin:@localhost:1521:xe"
=> "jdbc:oracle:thin:@127.0.0.1:1521:xe"

 
import java.sql.Connection;

Connection conn = DriverManager.getConnection(url, username, password);
=> Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "TEST", "1111");


=> 
String url = "jdbc:oracle:thin:@localhost:1521:xe";
String username = "TEST";
String password = "1111";
Connection conn = DriverManager.getConnection(url, username, password);




























































